# -*- coding: utf-8 -*-import tkinter as tkimport tkinter.ttk as ttkimport mathfrom core.utils import tbfrom core.base_module import CalcModuleclass EngineeringCalcModule(CalcModule):    key = "eng_calc"    title = "Инженерный справочник"    def __init__(self, app):        super().__init__(app)        self.canvas = None        self.current_calc = "ohm" # Текущий расчет                # --- ПЕРЕМЕННЫЕ (Общий пул, чтобы не плодить тысячи) ---        self.v1 = tk.StringVar(); self.v2 = tk.StringVar(); self.v3 = tk.StringVar()        self.v4 = tk.StringVar(); self.res1 = tk.StringVar(); self.res2 = tk.StringVar()                # Словарь расчетов: Название -> (Функция UI, Функция Рисования, Функция Расчета)        self.calculators = {            "Электроника": {                "Закон Ома (DC)": ("build_ohm", "draw_ohm", "calc_ohm"),                "Делитель напряжения": ("build_v_div", "draw_v_div", "calc_v_div"),                "Делитель тока": ("build_i_div", "draw_i_div", "calc_i_div"),                "Резистор для LED": ("build_led", "draw_led", "calc_led"),                "Мощность (DC)": ("build_power", "draw_power", "calc_power"),                "Время работы батареи": ("build_batt", "draw_batt", "calc_batt"),            },            "Пассивные компоненты": {                "Реактивное сопр. (XC/XL)": ("build_react", "draw_react", "calc_react"),                "LC Резонанс": ("build_reson", "draw_reson", "calc_reson"),                "R / L / C (Послед/Паралл)": ("build_rlc_comb", "draw_rlc_comb", "calc_rlc_comb"),                "Постоянная времени (RC)": ("build_rc", "draw_rc", "calc_rc"),            },            "RF и Физика": {                "Длина волны (λ)": ("build_lambda", "draw_lambda", "calc_lambda"),                "Скин-эффект (Skin Depth)": ("build_skin", "draw_skin", "calc_skin"),                "VSWR ↔ Return Loss": ("build_vswr", "draw_vswr", "calc_vswr"),                "Тепловой шум (Johnson)": ("build_noise", "draw_noise", "calc_noise"),                "Уравнение Фрииса (Friis)": ("build_friis", "draw_friis", "calc_friis"),            },            "Печатные платы (PCB)": {                "Сопротивление дорожки": ("build_trace_r", "draw_trace_r", "calc_trace_r"),                "Ток переходного отв. (Via)": ("build_via", "draw_via", "calc_via"),            }        }    def toolbar_actions(self):        return []    def build_ui(self, parent):        self.frame = tb.Frame(parent)                # Разделитель: Слева меню, Справа контент        paned = tb.PanedWindow(self.frame, orient="horizontal", bootstyle="light")        paned.pack(fill="both", expand=True, padx=10, pady=10)                # --- ЛЕВАЯ ЧАСТЬ (МЕНЮ) ---        nav_frame = tb.Frame(paned, width=250)        paned.add(nav_frame, weight=1)                tb.Label(nav_frame, text="Категории расчетов", font=("Segoe UI", 10, "bold")).pack(fill="x", pady=5)                # Дерево навигации        self.tree = ttk.Treeview(nav_frame, show="tree", bootstyle="primary")        self.tree.pack(fill="both", expand=True)        self.tree.bind("<<TreeviewSelect>>", self.on_select_calc)                # Заполняем дерево        for category, calcs in self.calculators.items():            cat_id = self.tree.insert("", "end", text=category, open=True)            for name in calcs:                self.tree.insert(cat_id, "end", text=name, values=(name,))        # --- ПРАВАЯ ЧАСТЬ (КОНТЕНТ) ---        content_frame = tb.Frame(paned)        paned.add(content_frame, weight=3)                # Заголовок        self.lbl_title = tb.Label(content_frame, text="Выберите расчет", font=("Segoe UI", 16, "bold"), bootstyle="primary")        self.lbl_title.pack(anchor="w", pady=(0, 20))                # Зона ввода (динамическая)        self.input_frame = tb.Labelframe(content_frame, text="Параметры", padding=15)        self.input_frame.pack(fill="x", pady=(0, 10))                # Зона результата        self.res_frame = tb.Frame(content_frame, padding=10, bootstyle="secondary")        self.res_frame.pack(fill="x", pady=(0, 10))        self.lbl_res_main = tb.Label(self.res_frame, textvariable=self.res1, font=("Consolas", 14, "bold"), bootstyle="inverse-secondary")        self.lbl_res_main.pack(side="left")        self.lbl_res_sub = tb.Label(self.res_frame, textvariable=self.res2, font=("Segoe UI", 10), bootstyle="inverse-secondary")        self.lbl_res_sub.pack(side="right", padx=10)        # Зона схемы (Canvas)        self.canvas = tk.Canvas(content_frame, bg="white", height=300, bd=0, highlightthickness=0)        self.canvas.pack(fill="both", expand=True)        # Запускаем первый расчет по умолчанию        first_cat = list(self.calculators.keys())[0]        first_calc = list(self.calculators[first_cat].keys())[0]        self.load_calc(first_calc)        return self.frame    def on_select_calc(self, event):        sel = self.tree.selection()        if not sel: return        item = self.tree.item(sel[0])        name = item['text']                # Ищем, есть ли такой расчет (это может быть категория)        found = False        for cat in self.calculators.values():            if name in cat:                self.load_calc(name)                found = True                break    def load_calc(self, name):        self.lbl_title.config(text=name)        self.current_calc = name                # Очистка        for widget in self.input_frame.winfo_children(): widget.destroy()        self.v1.set(""); self.v2.set(""); self.v3.set(""); self.v4.set("")        self.res1.set("Результат..."); self.res2.set("")        self.canvas.delete("all")                # Поиск функций        funcs = None        for cat in self.calculators.values():            if name in cat:                funcs = cat[name]                break                if funcs:            ui_func_name, draw_func_name, calc_func_name = funcs                        # 1. Строим UI            if hasattr(self, ui_func_name):                getattr(self, ui_func_name)()                        # 2. Рисуем схему            if hasattr(self, draw_func_name):                # Используем after, чтобы канвас успел отрисоваться                self.frame.after(50, lambda: getattr(self, draw_func_name)())                        # 3. Привязываем расчет (кнопка уже создается в build_generic, но можно и здесь)    # =========================================================================    #                               СТРОИТЕЛИ UI    # =========================================================================    def _add_inp(self, label, var, unit=""):        f = tb.Frame(self.input_frame); f.pack(fill="x", pady=2)        tb.Label(f, text=label, width=25).pack(side="left")        tb.Entry(f, textvariable=var).pack(side="left", fill="x", expand=True, padx=5)        tb.Label(f, text=unit, width=5).pack(side="left")        var.trace_add("write", lambda *args: self._do_calc())    def _add_btn(self):        # Кнопка не обязательна, если есть авторасчет (trace), но добавим для явности        tb.Button(self.input_frame, text="Рассчитать", command=self._do_calc, bootstyle="primary-outline").pack(fill="x", pady=10)    def _do_calc(self):        # Находим функцию расчета для текущего режима        for cat in self.calculators.values():            if self.current_calc in cat:                func_name = cat[self.current_calc][2]                if hasattr(self, func_name):                    try:                        getattr(self, func_name)()                    except Exception:                        pass # Игнорируем ошибки ввода пока не введено все                return    def _get(self, var):        try: return float(var.get().replace(",", "."))        except: return None    # --- UI Definitions ---    def build_ohm(self):        self._add_inp("Напряжение (U):", self.v1, "В")        self._add_inp("Сопротивление (R):", self.v2, "Ом")        tb.Label(self.input_frame, text="* Введите 2 значения, чтобы найти Ток", font=("Segoe UI", 8), foreground="gray").pack(anchor="w")        self._add_btn()    def build_v_div(self):        self._add_inp("Входное напр. (Vin):", self.v1, "В")        self._add_inp("R1 (Верхний):", self.v2, "Ом")        self._add_inp("R2 (Нижний):", self.v3, "Ом")        self._add_btn()    def build_i_div(self):        self._add_inp("Входной ток (Iin):", self.v1, "А")        self._add_inp("R1:", self.v2, "Ом")        self._add_inp("R2:", self.v3, "Ом")        self._add_btn()    def build_led(self):        self._add_inp("Напряжение питания (Vs):", self.v1, "В")        self._add_inp("Напряжение LED (Vf):", self.v2, "В")        self._add_inp("Ток LED (I):", self.v3, "мА")        self._add_btn()    def build_react(self):        self._add_inp("Частота (f):", self.v1, "Гц")        self._add_inp("Индуктивность (L):", self.v2, "Гн")        self._add_inp("Емкость (C):", self.v3, "Ф")        self._add_btn()    def build_reson(self):        self._add_inp("Индуктивность (L):", self.v1, "Гн")        self._add_inp("Емкость (C):", self.v2, "Ф")        self._add_btn()    def build_lambda(self):        self._add_inp("Частота (f):", self.v1, "МГц")        self._add_inp("Коэфф. укорочения (Vk):", self.v2, "")        self.v2.set("1.0") # Вакуум        self._add_btn()    def build_skin(self):        self._add_inp("Частота (f):", self.v1, "МГц")        # Выбор материала        f = tb.Frame(self.input_frame); f.pack(fill="x", pady=2)        tb.Label(f, text="Материал:", width=25).pack(side="left")        self.v2.set("Медь")        cb = tb.Combobox(f, textvariable=self.v2, values=["Медь", "Алюминий", "Золото", "Серебро"], state="readonly")        cb.pack(side="left", fill="x", expand=True)        cb.bind("<<ComboboxSelected>>", lambda e: self._do_calc())        self._add_btn()    def build_trace_r(self):        self._add_inp("Длина (L):", self.v1, "мм")        self._add_inp("Ширина (W):", self.v2, "мм")        self._add_inp("Толщина (T):", self.v3, "мкм") # 35 um        self.v3.set("35")        self._add_btn()    def build_rlc_comb(self):        # Выбор типа        f = tb.Frame(self.input_frame); f.pack(fill="x", pady=5)        self.v3.set("Резисторы (R)")        cb = tb.Combobox(f, textvariable=self.v3, values=["Резисторы (R)", "Конденсаторы (C)", "Индуктивности (L)"], state="readonly")        cb.pack(fill="x")        cb.bind("<<ComboboxSelected>>", lambda e: self._do_calc())                self._add_inp("Номинал 1:", self.v1, "")        self._add_inp("Номинал 2:", self.v2, "")        self._add_btn()    def build_vswr(self):        self._add_inp("VSWR (КСВ):", self.v1, "")        self._add_btn()    def build_noise(self):        self._add_inp("Температура (T):", self.v1, "K")        self._add_inp("Полоса (B):", self.v2, "МГц")        self._add_inp("Сопротивление (R):", self.v3, "Ом")        self.v1.set("290")        self._add_btn()    def build_power(self):        self._add_inp("Напряжение (U):", self.v1, "В")        self._add_inp("Ток (I):", self.v2, "А")        self._add_btn()    def build_batt(self):        self._add_inp("Емкость батареи:", self.v1, "мАч")        self._add_inp("Потребление тока:", self.v2, "мА")        self._add_btn()    def build_rc(self):        self._add_inp("Сопротивление (R):", self.v1, "Ом")        self._add_inp("Емкость (C):", self.v2, "мкФ")        self._add_btn()    def build_via(self):        self._add_inp("Диаметр Via (d):", self.v1, "мм")        self._add_inp("Толщина покрытия:", self.v2, "мкм")        self.v2.set("25")        self._add_btn()    def build_friis(self):        self._add_inp("Мощность Tx (Ptx):", self.v1, "dBm")        self._add_inp("Усиление Gtx:", self.v2, "dBi")        self._add_inp("Усиление Grx:", self.v3, "dBi")        self._add_inp("Частота (МГц):", self.v4, "МГц")        # Дистанцию впихнем в отдельный фрейм кодом ниже (хак для 5 параметров)        f = tb.Frame(self.input_frame); f.pack(fill="x")        tb.Label(f, text="Дистанция (км):", width=25).pack(side="left")        self.dist_var = tk.StringVar(value="1.0")        tb.Entry(f, textvariable=self.dist_var).pack(side="left", fill="x", expand=True)        self.dist_var.trace_add("write", lambda *args: self._do_calc())        self._add_btn()    # =========================================================================    #                               МАТЕМАТИКА    # =========================================================================    def calc_ohm(self):        u, r = self._get(self.v1), self._get(self.v2)        if u and r:            i = u / r            self.res1.set(f"I = {i:.4f} А")            self.res2.set(f"P = {u*i:.4f} Вт")    def calc_v_div(self):        vin, r1, r2 = self._get(self.v1), self._get(self.v2), self._get(self.v3)        if vin is not None and r1 is not None and r2 is not None:            vout = vin * (r2 / (r1 + r2))            self.res1.set(f"Vout = {vout:.4f} В")            self.res2.set(f"Ток делителя: {(vin/(r1+r2))*1000:.2f} мА")    def calc_i_div(self):        iin, r1, r2 = self._get(self.v1), self._get(self.v2), self._get(self.v3)        if iin is not None and r1 is not None and r2 is not None:            i1 = iin * (r2 / (r1 + r2))            i2 = iin * (r1 / (r1 + r2))            self.res1.set(f"I(R1)={i1:.4f} A, I(R2)={i2:.4f} A")    def calc_led(self):        vs, vf, i_ma = self._get(self.v1), self._get(self.v2), self._get(self.v3)        if vs is not None and vf is not None and i_ma is not None:            r = (vs - vf) / (i_ma / 1000.0)            p = (i_ma/1000.0)**2 * r            self.res1.set(f"R = {r:.1f} Ом")            self.res2.set(f"Мощность R: {p:.3f} Вт")    def calc_react(self):        f = self._get(self.v1)        l, c = self._get(self.v2), self._get(self.v3)        res_str = ""        if f:            if l: res_str += f"XL = {2*math.pi*f*l:.2f} Ом.  "            if c: res_str += f"XC = {1/(2*math.pi*f*c):.2f} Ом."        self.res1.set(res_str)    def calc_reson(self):        l, c = self._get(self.v1), self._get(self.v2)        if l and c:            f = 1 / (2 * math.pi * math.sqrt(l * c))            self.res1.set(f"Fрез = {f:.2f} Гц")    def calc_lambda(self):        f_mhz, vk = self._get(self.v1), self._get(self.v2)        if f_mhz and vk:            lam = (299.792 / f_mhz) * vk            self.res1.set(f"λ = {lam:.3f} м")            self.res2.set(f"λ/4 = {lam/4:.3f} м")    def calc_skin(self):        f_mhz = self._get(self.v1)        mat = self.v2.get()        if f_mhz:            # depth = 503 * sqrt(rho / (mu_r * f))  [meters]            # Copper rho=1.68e-8, Al=2.82e-8, Au=2.44e-8, Ag=1.59e-8            rho = 1.68e-8             if "Алюм" in mat: rho = 2.82e-8            elif "Зол" in mat: rho = 2.44e-8            elif "Сер" in mat: rho = 1.59e-8                        f = f_mhz * 1e6            depth = math.sqrt((2 * rho) / (2 * math.pi * f * 4e-7 * math.pi))             self.res1.set(f"Глубина: {depth*1e6:.2f} мкм")    def calc_trace_r(self):        l, w, t = self._get(self.v1), self._get(self.v2), self._get(self.v3)        if l and w and t:            # R = rho * L / A. Copper rho = 1.68e-8 Ohm*m            # L, W in mm, T in um.            # A = W*T * 1e-9 m^2. L = L * 1e-3 m.            rho = 1.68e-8            area = (w * 1e-3) * (t * 1e-6)            length = l * 1e-3            r = rho * length / area            self.res1.set(f"R = {r:.4f} Ом")    def calc_rlc_comb(self):        mode = self.v3.get()        v1, v2 = self._get(self.v1), self._get(self.v2)        if v1 is not None and v2 is not None:            ser, par = 0.0, 0.0            if "Резист" in mode or "Индук" in mode:                ser = v1 + v2                par = (v1 * v2) / (v1 + v2) if (v1+v2)!=0 else 0            else: # Конденсаторы (наоборот)                par = v1 + v2                ser = (v1 * v2) / (v1 + v2) if (v1+v2)!=0 else 0                        self.res1.set(f"Послед: {ser:.2f} | Паралл: {par:.2f}")    def calc_vswr(self):        vswr = self._get(self.v1)        if vswr and vswr >= 1:            gamma = (vswr - 1) / (vswr + 1)            rl = -20 * math.log10(gamma) if gamma > 0 else 999            ml = -10 * math.log10(1 - gamma**2) if gamma < 1 else 999            self.res1.set(f"RL = {rl:.2f} dB")            self.res2.set(f"Mismatch Loss = {ml:.3f} dB")    def calc_noise(self):        t, b_mhz, r = self._get(self.v1), self._get(self.v2), self._get(self.v3)        if t and b_mhz and r:            # V_noise = sqrt(4 * k * T * B * R)            k = 1.38e-23            b = b_mhz * 1e6            v_n = math.sqrt(4 * k * t * b * r)            self.res1.set(f"V шум = {v_n*1e6:.2f} мкВ")            p_dbm = 10 * math.log10(k * t * b * 1000)            self.res2.set(f"Мощность шума: {p_dbm:.1f} dBm")    def calc_power(self):        u, i = self._get(self.v1), self._get(self.v2)        if u is not None and i is not None:            self.res1.set(f"P = {u*i:.2f} Вт")    def calc_batt(self):        cap, curr = self._get(self.v1), self._get(self.v2)        if cap and curr:            # Простое деление, обычно берут к-т 0.7-0.9            time = (cap / curr) * 0.85            self.res1.set(f"Время ~ {time:.1f} ч")            self.res2.set("(с учетом к-та 0.85)")    def calc_rc(self):        r, c = self._get(self.v1), self._get(self.v2)        if r and c:            tau = r * (c * 1e-6)            self.res1.set(f"τ = {tau:.4f} с")            self.res2.set(f"5τ (99%) = {5*tau:.4f} с")    def calc_via(self):        d_mm, t_um = self._get(self.v1), self._get(self.v2)        if d_mm and t_um:            # Упрощенная формула IPC-2221            # I = k * dT^0.44 * A^0.725 (слишком сложно для сниппета)            # Приближенно: A_eff = pi * d * t            # Считаем сечение меди            area_mils2 = (d_mm/0.0254) * math.pi * (t_um/25.4 * 1000) * 0.05 # Грубая прикидка            # Для надежности просто площадь кольца            area_mm2 = math.pi * d_mm * (t_um/1000.0)            # Ток (очень грубо 200 А/мм2 для внешнего слоя при 10С)            i_max = area_mm2 * 200 * 0.5             self.res1.set(f"Ток (прибл) ~ {i_max:.2f} А")    def calc_friis(self):        ptx, gtx, grx, f = self._get(self.v1), self._get(self.v2), self._get(self.v3), self._get(self.v4)        dist_km = float(self.dist_var.get())        if ptx is not None and f and dist_km:            # FSPL = 20log(d) + 20log(f) + 32.44            fspl = 20*math.log10(dist_km) + 20*math.log10(f) + 32.44            prx = ptx + gtx + grx - fspl            self.res1.set(f"Prx = {prx:.2f} dBm")            self.res2.set(f"Затухание трассы: {fspl:.1f} dB")    # =========================================================================    #                               РИСОВАНИЕ (СХЕМЫ)    # =========================================================================    def _draw_res(self, c, x, y, name="R"):        c.create_line(x, y, x+10, y, width=2)        c.create_line(x+10, y, x+15, y-5, width=2)        c.create_line(x+15, y-5, x+25, y+5, width=2)        c.create_line(x+25, y+5, x+35, y-5, width=2)        c.create_line(x+35, y-5, x+40, y, width=2)        c.create_line(x+40, y, x+50, y, width=2)        c.create_text(x+25, y-15, text=name, font=("Segoe UI", 9, "bold"))    def _draw_cap(self, c, x, y, name="C"):        c.create_line(x, y, x+22, y, width=2)        c.create_line(x+22, y-10, x+22, y+10, width=2)        c.create_line(x+28, y-10, x+28, y+10, width=2)        c.create_line(x+28, y, x+50, y, width=2)        c.create_text(x+25, y-15, text=name, font=("Segoe UI", 9, "bold"))    def _draw_ind(self, c, x, y, name="L"):        c.create_line(x, y, x+10, y, width=2)        # 3 дуги        for i in range(3):            c.create_arc(x+10 + i*10, y-5, x+20 + i*10, y+5, start=0, extent=180, style="arc", width=2)        c.create_line(x+40, y, x+50, y, width=2)        c.create_text(x+25, y-15, text=name, font=("Segoe UI", 9, "bold"))    def draw_ohm(self):        c = self.canvas        c.create_text(200, 30, text="Схема измерения тока", font=("Segoe UI", 10))        # Источник        c.create_oval(50, 100, 90, 140, width=2)        c.create_text(70, 120, text="V")        # Провода        c.create_line(70, 100, 70, 50, 200, 50, width=2)        c.create_line(70, 140, 70, 200, 200, 200, width=2)        # Резистор (вертикальный)        c.create_line(200, 50, 200, 100, width=2)        c.create_rectangle(190, 100, 210, 150, width=2) # Просто прямоугольник        c.create_text(225, 125, text="R")        c.create_line(200, 150, 200, 200, width=2)        # Стрелка тока        c.create_line(120, 60, 150, 60, arrow="last", fill="red", width=2)        c.create_text(135, 75, text="I", fill="red")    def draw_v_div(self):        c = self.canvas        c.create_line(100, 50, 200, 50, width=2) # Top wire        self._draw_res(c, 200, 50, "R1") # Горизонтальный? Нет, делитель обычно вертикальный        # Перерисуем        c.delete("all")        c.create_text(200, 30, text="Делитель напряжения", font=("Segoe UI", 10))        c.create_line(150, 50, 250, 50, width=2) # In        c.create_text(130, 50, text="Vin")                # R1 (Top)        c.create_rectangle(240, 50, 260, 100, width=2)        c.create_text(275, 75, text="R1")                # Mid point        c.create_line(250, 100, 250, 130, width=2)        c.create_line(250, 115, 350, 115, width=2) # Out        c.create_text(370, 115, text="Vout")                # R2 (Bot)        c.create_rectangle(240, 130, 260, 180, width=2)        c.create_text(275, 155, text="R2")                # Gnd        c.create_line(250, 180, 250, 200, width=2)        c.create_line(230, 200, 270, 200, width=2)    def draw_i_div(self):        c = self.canvas        c.create_text(200, 30, text="Делитель тока", font=("Segoe UI", 10))        # Top rail        c.create_line(100, 50, 300, 50, width=2)        c.create_line(100, 50, 100, 100, arrow="last", width=2) # I_in        c.create_text(80, 75, text="I_in")                # R1 leg        c.create_line(180, 50, 180, 80, width=2)        c.create_rectangle(170, 80, 190, 130, width=2)        c.create_text(200, 105, text="R1")        c.create_line(180, 130, 180, 160, width=2)                # R2 leg        c.create_line(260, 50, 260, 80, width=2)        c.create_rectangle(250, 80, 270, 130, width=2)        c.create_text(280, 105, text="R2")        c.create_line(260, 130, 260, 160, width=2)                # Bot rail        c.create_line(150, 160, 300, 160, width=2)    def draw_led(self):        c = self.canvas        # Vs -> R -> LED -> Gnd        c.create_text(50, 100, text="+Vs")        c.create_line(60, 100, 100, 100, width=2)        self._draw_res(c, 100, 100, "R")        c.create_line(150, 100, 200, 100, width=2)        # LED Symbol        c.create_line(200, 85, 200, 115, width=2) # Anode        c.create_polygon(200, 85, 230, 100, 200, 115, fill="red") # Triangle        c.create_line(230, 85, 230, 115, width=2) # Cathode        # Arrows        c.create_line(210, 80, 225, 65, arrow="last", fill="red")        c.create_line(220, 80, 235, 65, arrow="last", fill="red")                c.create_line(230, 100, 260, 100, width=2)        c.create_text(280, 100, text="GND")    def draw_react(self):        c = self.canvas        self._draw_cap(c, 100, 80, "C")        self._draw_ind(c, 100, 150, "L")        c.create_text(250, 115, text="f (частота)", font=("Segoe UI", 14))    def draw_reson(self):        c = self.canvas        c.create_text(200, 30, text="LC Контур", font=("Segoe UI", 10))        c.create_line(100, 100, 300, 100, width=2)        c.create_line(100, 100, 100, 150, width=2)        c.create_line(300, 100, 300, 150, width=2)        # L        self._draw_ind(c, 120, 150, "L") # Схематично        # C        self._draw_cap(c, 220, 150, "C")        c.create_line(100, 150, 300, 150, width=2)    def draw_lambda(self):        c = self.canvas        c.create_line(50, 100, 350, 100, fill="gray")        # Sinewave        points = []        for x in range(50, 351):            y = 100 - 40 * math.sin((x-50) * 0.05)            points.append(x)            points.append(y)        c.create_line(points, smooth=True, width=2, fill="blue")        # Dimension        c.create_line(50+30, 150, 50+30+125, 150, arrow="both")        c.create_text(145, 165, text="λ (Длина волны)")    def draw_skin(self):        c = self.canvas        # Conductor cross section        c.create_oval(150, 50, 250, 150, fill="#d87a48", outline="") # Copper core        c.create_oval(150, 50, 250, 150, width=2) # Border        # Skin ring        c.create_oval(160, 60, 240, 140, outline="red", dash=(4,2), width=2)        c.create_line(200, 150, 200, 140, arrow="last")        c.create_text(200, 165, text="Skin Depth (δ)")    def draw_trace_r(self):        c = self.canvas        # 3D-ish trace        c.create_rectangle(100, 100, 300, 140, fill="#b87333", outline="black")        c.create_line(100, 100, 130, 80, 330, 80, 300, 100, fill="black") # Top face lines        c.create_line(330, 80, 330, 120, 300, 140, fill="black") # Side face        c.create_text(200, 155, text="Длина (L)")        c.create_text(350, 100, text="Толщина (T)")        c.create_text(80, 120, text="Ширина (W)")    def draw_rlc_comb(self):        c = self.canvas        # Series        c.create_text(100, 40, text="Последовательно")        c.create_line(50, 60, 150, 60, width=2)        c.create_rectangle(70, 50, 90, 70, width=2)        c.create_rectangle(110, 50, 130, 70, width=2)        # Parallel        c.create_text(300, 40, text="Параллельно")        c.create_line(250, 60, 350, 60, width=2)        c.create_line(280, 60, 280, 90, width=2); c.create_rectangle(270, 70, 290, 90, width=2)        c.create_line(320, 60, 320, 90, width=2); c.create_rectangle(310, 70, 330, 90, width=2)        c.create_line(280, 90, 320, 90, width=2)    def draw_rc(self):        c = self.canvas        c.create_line(50, 100, 100, 100, width=2)        self._draw_res(c, 100, 100, "R")        c.create_line(150, 100, 200, 100, width=2)        self._draw_cap(c, 200, 100, "C")        c.create_line(250, 100, 250, 150, width=2) # To Gnd        c.create_line(230, 150, 270, 150, width=2)    def draw_via(self):        c = self.canvas        # Top pad        c.create_oval(150, 50, 250, 70, fill="gold", outline="black")        # Barrel        c.create_line(150, 60, 150, 150, width=2)        c.create_line(250, 60, 250, 150, width=2)        # Bot pad        c.create_oval(150, 140, 250, 160, fill="gold", outline="black")        c.create_line(170, 150, 230, 150, arrow="both")        c.create_text(200, 165, text="Diameter (d)")    def draw_friis(self):        c = self.canvas        # Ant 1        c.create_polygon(50, 100, 20, 80, 20, 120, fill="gray", outline="black")        c.create_text(35, 130, text="Tx")        # Ant 2        c.create_polygon(350, 100, 380, 80, 380, 120, fill="gray", outline="black")        c.create_text(365, 130, text="Rx")        # Waves        for i in range(3):            c.create_arc(60+i*20, 80-i*10, 80+i*20, 120+i*10, start=-60, extent=120, style="arc", outline="blue", width=2)                c.create_text(200, 50, text="Свободное пространство")    def draw_power(self):        self.draw_ohm() # Same diagram    def draw_batt(self):        c = self.canvas        c.create_rectangle(100, 80, 180, 140, width=2)        c.create_rectangle(130, 70, 150, 80, fill="black") # Terminal        c.create_text(140, 110, text="Battery", font=("Segoe UI", 12))        c.create_text(250, 110, text="Load", font=("Segoe UI", 12))        c.create_line(180, 110, 220, 110, arrow="last", width=2)        c.create_text(200, 95, text="I (mA)")    def draw_vswr(self):        c = self.canvas        c.create_line(50, 100, 350, 100, width=2)        # Incident        c.create_line(100, 80, 150, 80, arrow="last", fill="green", width=3)        c.create_text(125, 65, text="Fwd", fill="green")        # Reflected        c.create_line(250, 80, 200, 80, arrow="last", fill="red", width=3)        c.create_text(225, 65, text="Ref", fill="red")        c.create_rectangle(350, 80, 370, 120, fill="gray") # Load    def draw_noise(self):        c = self.canvas        self._draw_res(c, 150, 100, "R")        c.create_text(150, 60, text="Генерация теплового шума", font=("Segoe UI", 10))        # Random wiggly line above        points = []        import random        for x in range(100, 200, 5):            points.append(x)            points.append(40 + random.randint(-5, 5))        c.create_line(points, fill="orange")