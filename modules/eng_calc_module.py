# -*- coding: utf-8 -*-import tkinter as tkimport tkinter.ttk as ttkimport mathimport randomfrom core.utils import tbfrom core.base_module import CalcModuleclass EngineeringCalcModule(CalcModule):    key = "eng_calc"    title = "Инженерный справочник"    def __init__(self, app):        super().__init__(app)        self.canvas = None        self.current_calc = "ohm"                # Переменные        self.v1 = tk.StringVar(); self.v2 = tk.StringVar(); self.v3 = tk.StringVar()        self.v4 = tk.StringVar(); self.res1 = tk.StringVar(); self.res2 = tk.StringVar()        self.dist_var = tk.StringVar(value="1.0")                # Структура: Категория -> {Название: (UI_функция, Draw_функция, Calc_функция)}        self.calculators = {            "Электроника": {                "Закон Ома (DC)": ("build_ohm", "draw_ohm", "calc_ohm"),                "Делитель напряжения": ("build_v_div", "draw_v_div", "calc_v_div"),                "Делитель тока": ("build_i_div", "draw_i_div", "calc_i_div"),                "Резистор для LED": ("build_led", "draw_led", "calc_led"),                "Мощность (P=UI)": ("build_power", "draw_power", "calc_power"),                "Батарея (Время)": ("build_batt", "draw_batt", "calc_batt"),            },            "RLC Компоненты": {                "Реактивное сопр.": ("build_react", "draw_react", "calc_react"),                "LC Резонанс": ("build_reson", "draw_reson", "calc_reson"),                "Соединение R/L/C": ("build_rlc_comb", "draw_rlc_comb", "calc_rlc_comb"),                "RC-цепь (Время)": ("build_rc", "draw_rc", "calc_rc"),            },            "RF (ВЧ)": {                "Длина волны (λ)": ("build_lambda", "draw_lambda", "calc_lambda"),                "Скин-эффект": ("build_skin", "draw_skin", "calc_skin"),                "VSWR (КСВ)": ("build_vswr", "draw_vswr", "calc_vswr"),                "Тепловой шум": ("build_noise", "draw_noise", "calc_noise"),                "Дальность (Friis)": ("build_friis", "draw_friis", "calc_friis"),            },            "Печатные платы": {                "Сопротивление дорожки": ("build_trace_r", "draw_trace_r", "calc_trace_r"),                "Ток переходного (Via)": ("build_via", "draw_via", "calc_via"),            }        }                # --- БАЗА ЗНАНИЙ (ОПИСАНИЯ) ---        self.descriptions = {            "Закон Ома (DC)": """ФИЗИЧЕСКИЙ СМЫСЛ:Закон Ома — эмпирический физический закон, определяющий связь между электродвижущей силой источника (или напряжением U), силой тока (I) и сопротивлением проводника (R).Для участка цепи закон гласит: сила тока прямо пропорциональна напряжению и обратно пропорциональна сопротивлению.ФОРМУЛА:I = U / RГде:• I — сила тока (Ампер)• U — напряжение (Вольт)• R — сопротивление (Ом)ПРИМЕНЕНИЕ:Является базовым законом электротехники. Используется для расчета режимов работы электронных компонентов, подбора сечения проводов, анализа падения напряжения и проектирования любых электрических цепей.""",            "Делитель напряжения": """ФИЗИЧЕСКИЙ СМЫСЛ:Линейная электрическая схема, выходное напряжение которой составляет часть входного напряжения. Коэффициент передачи определяется соотношением резисторов плеч делителя.Ток, протекающий через делитель (ток холостого хода), должен быть в 10–100 раз больше тока нагрузки, чтобы выходное напряжение оставалось стабильным.ФОРМУЛА:Uвых = Uвх * R2 / (R1 + R2)ПРИМЕНЕНИЕ:1. Согласование логических уровней (например, датчик 5В к входу МК 3.3В).2. Создание опорных напряжений для АЦП и компараторов.3. Измерение высоких напряжений (масштабирование сигнала).4. Регулировка громкости (потенциометр — это регулируемый делитель).""",            "Делитель тока": """ФИЗИЧЕСКИЙ СМЫСЛ:Правило, описывающее распределение электрического тока в цепи, состоящей из параллельно соединенных сопротивлений. Согласно первому закону Кирхгофа, сумма токов в узле равна нулю. Ток распределяется обратно пропорционально проводимости ветвей: большая часть тока течет по пути наименьшего сопротивления.ФОРМУЛА:Ix = I_общ * (R_экв / Rx)Для двух резисторов:I(R1) = I_общ * R2 / (R1 + R2)ПРИМЕНЕНИЕ:1. Расчет измерительных шунтов.2. Анализ параллельного включения биполярных транзисторов или светодиодов.3. Проектирование фильтров.""",            "Резистор для LED": """ФИЗИЧЕСКИЙ СМЫСЛ:Светодиод (LED) имеет нелинейную вольт-амперную характеристику (ВАХ) экспоненциального типа. Даже небольшое превышение прямого напряжения вызывает лавинообразный рост тока, что приводит к тепловому пробою p-n перехода.Токоограничивающий резистор (балласт) линеаризует цепь и задает рабочую точку на ВАХ.ФОРМУЛА:R = (Uпит - Uled) / IledГде Uled — падение напряжения на диоде (зависит от цвета: красный ~1.8В, синий ~3.3В).ПРИМЕНЕНИЕ:Обязателен при подключении светодиодов к источникам напряжения, оптопар, индикаторов.""",            "Мощность (P=UI)": """ФИЗИЧЕСКИЙ СМЫСЛ:Электрическая мощность характеризует скорость передачи или преобразования электрической энергии. В резистивных цепях электрическая энергия необратимо преобразуется в тепловую (Джоулево тепло).ФОРМУЛЫ:P = U * IP = I² * R  (для потерь на сопротивлении)P = U² / R  (для нагрузки при известном напряжении)ПРИМЕНЕНИЕ:1. Выбор резисторов по рассеиваемой мощности (0.125Вт, 0.25Вт и т.д.).2. Расчет энергопотребления устройства.3. Оценка КПД блоков питания.4. Тепловой расчет радиаторов для транзисторов.""",            "Батарея (Время)": """ФИЗИЧЕСКИЙ СМЫСЛ:Оценка времени автономной работы устройства. Емкость аккумулятора (C) измеряется в Ампер-часах (А·ч) или миллиампер-часах (мА·ч) и показывает заряд, который батарея может отдать.Реальное время работы меньше теоретического из-за закона Пёкерта (эффективная емкость падает при больших токах разряда), саморазряда и КПД преобразователя питания.ФОРМУЛА:T (час) ≈ (Емкость [мАч] / Ток [мА]) * КГде К ≈ 0.7...0.85 — коэффициент запаса.ПРИМЕНЕНИЕ:Проектирование носимой электроники, IoT-датчиков, расчет бесперебойного питания.""",            "Реактивное сопр.": """ФИЗИЧЕСКИЙ СМЫСЛ:Импеданс (полное сопротивление) цепи переменного тока состоит из активной (R) и реактивной (X) частей. Реактивное сопротивление возникает из-за накопления энергии в электрическом (C) или магнитном (L) поле.В отличие от резистора, реактивные элементы не рассеивают энергию в тепло, а возвращают её в цепь, сдвигая фазу тока относительно напряжения.ФОРМУЛЫ:Индуктивное: XL = 2 * π * f * L  (растет с частотой)Емкостное:   XC = 1 / (2 * π * f * C)  (падает с частотой)ПРИМЕНЕНИЕ:Расчет фильтров частот, блокировочных конденсаторов, согласующих цепей, цепей коррекции коэффициента мощности.""",            "LC Резонанс": """ФИЗИЧЕСКИЙ СМЫСЛ:Явление резкого возрастания амплитуды вынужденных колебаний в колебательном контуре. На резонансной частоте индуктивное и емкостное сопротивления компенсируют друг друга (XL = XC), и импеданс идеального последовательного контура стремится к нулю (или к бесконечности для параллельного).ФОРМУЛА (Томсона):f_рез = 1 / (2 * π * √LC)ПРИМЕНЕНИЕ:1. Выделение полезного сигнала в радиоприемниках (избирательность).2. Задание частоты в генераторах и кварцевых резонаторах.3. Согласование антенн.4. Беспроводная передача энергии.""",            "Соединение R/L/C": """ФИЗИЧЕСКИЙ СМЫСЛ:Законы эквивалентного преобразования схем.1. Резисторы и Индуктивности:   - Последовательно: Номиналы складываются (увеличение).   - Параллельно: Проводимости складываются (уменьшение итогового номинала).2. Конденсаторы:   - Действуют наоборот. Параллельное соединение увеличивает площадь обкладок (емкость растет), последовательное — увеличивает толщину диэлектрика (емкость падает).ПРИМЕНЕНИЕ:Получение нестандартных номиналов, увеличение рабочего напряжения конденсаторов (последовательно) или допустимого тока/мощности резисторов.""",            "RC-цепь (Время)": """ФИЗИЧЕСКИЙ СМЫСЛ:Переходный процесс заряда или разряда конденсатора через резистор описывается экспоненциальным законом.Постоянная времени τ (Тау) характеризует инерционность системы.За время t = τ напряжение достигает 63.2% от максимума.За время t = 5τ процесс считается завершенным (99.3%).ФОРМУЛА:τ = R * CПРИМЕНЕНИЕ:1. Формирование задержек включения (Reset цепи).2. Фильтрация дребезга контактов.3. Простейшие ЦАП (ШИМ -> Аналог).4. Частотные фильтры первого порядка.""",            "Длина волны (Lambda)": """ФИЗИЧЕСКИЙ СМЫСЛ:Расстояние, на которое распространяется фаза электромагнитной волны за один период колебания. Это фундаментальный параметр в радиотехнике, определяющий размеры антенн.В реальных средах (кабель, текстолит) скорость света меньше, чем в вакууме, поэтому длина волны сокращается на коэффициент укорочения (Vk).ФОРМУЛА:λ = (c / f) * VkГде c ≈ 300 000 км/с.ПРИМЕНЕНИЕ:1. Расчет длины антенн (полуволновой диполь λ/2).2. Проектирование линий задержки.3. Расчет волноводов и резонаторов.""",            "Скин-эффект": """ФИЗИЧЕСКИЙ СМЫСЛ:Эффект вытеснения переменного тока высокой частоты к поверхности проводника. Возникает из-за вихревых токов, индуцируемых переменным магнитным полем внутри проводника.Глубина скин-слоя (δ) — это расстояние от поверхности, на котором плотность тока убывает в e (2.718) раз.СЛЕДСТВИЕ:На высоких частотах (МГц, ГГц) работает только тонкий поверхностный слой меди. Сопротивление провода растет.ПРИМЕНЕНИЕ:1. Использование полых проводников и волноводов.2. Покрытие медных проводников серебром (уменьшение R) или золотом (защита от окисления, т.к. оксиды плохо проводят).3. Литцендрат (многожильный изолированный провод) для ВЧ трансформаторов.""",            "VSWR (КСВ)": """ФИЗИЧЕСКИЙ СМЫСЛ:Коэффициент Стоячей Волны по напряжению (КСВН или VSWR). Характеризует степень согласования источника сигнала (передатчика) и нагрузки (антенны).Если импедансы не равны, часть энергии отражается от нагрузки обратно в передатчик, образуя стоячую волну (интерференцию падающей и отраженной волн).ЗНАЧЕНИЯ:1.0 — Идеал (вся энергия ушла в антенну).< 1.5 — Отлично.> 2.0 — Плохо (потеря более 10% мощности, риск перегрева передатчика).ПРИМЕНЕНИЕ:Настройка антенно-фидерных трактов.""",            "Тепловой шум": """ФИЗИЧЕСКИЙ СМЫСЛ:Шум Джонсона-Найквиста. Белый шум, возникающий в любом проводнике из-за хаотического теплового движения электронов. Существует даже при отсутствии тока.Является фундаментальным физическим ограничением чувствительности радиоприемников.ФОРМУЛА:Pn = k * T * BГде: k — постоянная Больцмана, T — температура (Кельвин), B — полоса частот (Гц).ПРИМЕНЕНИЕ:1. Расчет коэффициента шума усилителей.2. Проектирование высокочувствительных датчиков и радиотелескопов.""",            "Дальность (Friis)": """ФИЗИЧЕСКИЙ СМЫСЛ:Уравнение передачи Фрииса описывает мощность сигнала, полученную приемной антенной, при условии прямой видимости и отсутствия препятствий.Показывает, что мощность сигнала падает пропорционально квадрату расстояния и квадрату частоты.ПРИМЕНЕНИЕ:Расчет энергетического бюджета (Link Budget) радиолиний: спутники, Wi-Fi мосты, радиорелейные линии. Позволяет оценить максимальную дальность связи.""",            "Сопротивление дорожки": """ФИЗИЧЕСКИЙ СМЫСЛ:Печатный проводник на плате имеет конечное активное сопротивление, зависящее от длины, ширины и толщины фольги (обычно 18 или 35 мкм).Протекание тока вызывает падение напряжения (IR Drop) и нагрев проводника.ПРИМЕНЕНИЕ:1. Проектирование силовых шин питания (VCC, GND).2. Обеспечение целостности питания мощных процессоров/FPGA.3. Предотвращение перегрева дорожек при больших токах.""",            "Ток переходного (Via)": """ФИЗИЧЕСКИЙ СМЫСЛ:Переходное отверстие (Via) — это тонкостенная металлизированная трубка. Она имеет гораздо большее сопротивление и индуктивность, чем сплошной полигон.Превышение допустимого тока вызывает разогрев и разрушение металлизации ("отгорание" перехода).ПРИМЕНЕНИЕ:Проектирование силовых слоев. Для пропускания больших токов используют группы (массивы) переходных отверстий (Via Stitching)."""        }    def toolbar_actions(self): return []    def build_ui(self, parent):        self.frame = tb.Frame(parent)        paned = tb.Panedwindow(self.frame, orient="horizontal", bootstyle="light")        paned.pack(fill="both", expand=True, padx=10, pady=10)                # Меню        nav_frame = tb.Frame(paned, width=260)        paned.add(nav_frame, weight=1)        self.tree = ttk.Treeview(nav_frame, show="tree", bootstyle="primary")        self.tree.pack(fill="both", expand=True)        self.tree.bind("<<TreeviewSelect>>", self.on_select_calc)                for category, calcs in self.calculators.items():            cat_id = self.tree.insert("", "end", text=category, open=True)            for name in calcs: self.tree.insert(cat_id, "end", text=name, values=(name,))        # Контент        right_container = tb.Frame(paned)        paned.add(right_container, weight=3)        self.lbl_title = tb.Label(right_container, text="Выберите расчет", font=("Segoe UI", 16, "bold"), bootstyle="primary")        self.lbl_title.pack(anchor="w", pady=(0, 10))        self.tabs = ttk.Notebook(right_container, bootstyle="info")        self.tabs.pack(fill="both", expand=True)        self.tab_calc = tb.Frame(self.tabs, padding=15)        self.tabs.add(self.tab_calc, text=" Калькулятор ")        self.tab_desc = tb.Frame(self.tabs, padding=15)        self.tabs.add(self.tab_desc, text=" Теория ")        self.input_frame = tb.Labelframe(self.tab_calc, text="Входные данные", padding=15)        self.input_frame.pack(fill="x", pady=(0, 10))                self.res_frame = tb.Frame(self.tab_calc, padding=10, bootstyle="secondary")        self.res_frame.pack(fill="x", pady=(0, 10))        self.lbl_res_main = tb.Label(self.res_frame, textvariable=self.res1, font=("Consolas", 14, "bold"), bootstyle="inverse-secondary")        self.lbl_res_main.pack(side="left")        self.lbl_res_sub = tb.Label(self.res_frame, textvariable=self.res2, font=("Segoe UI", 10), bootstyle="inverse-secondary")        self.lbl_res_sub.pack(side="right", padx=10)        self.canvas = tk.Canvas(self.tab_calc, bg="white", height=300, bd=0, highlightthickness=0)        self.canvas.pack(fill="both", expand=True)        # Теория        self.txt_desc = tb.Text(self.tab_desc, wrap="word", font=("Segoe UI", 11),  bd=0, highlightthickness=0)        self.txt_desc.pack(fill="both", expand=True)        self.txt_desc.tag_config("header", font=("Segoe UI", 12, "bold"), foreground="#2c3e50", spacing3=5)        self.txt_desc.tag_config("body", font=("Segoe UI", 11), spacing1=2, spacing2=2)        self.load_calc("Закон Ома (DC)")        return self.frame    def on_select_calc(self, event):        sel = self.tree.selection()        if not sel: return        item = self.tree.item(sel[0])        name = item['text']        for cat in self.calculators.values():            if name in cat: self.load_calc(name); break    def load_calc(self, name):        self.lbl_title.config(text=name)        self.current_calc = name                for w in self.input_frame.winfo_children(): w.destroy()        self.v1.set(""); self.v2.set(""); self.v3.set(""); self.v4.set("")        self.res1.set("..."); self.res2.set("")        if self.canvas: self.canvas.delete("all")                funcs = None        for cat in self.calculators.values():            if name in cat: funcs = cat[name]; break        if funcs:            ui_f, draw_f, calc_f = funcs            if hasattr(self, ui_f): getattr(self, ui_f)()            if hasattr(self, draw_f): self.frame.after(100, lambda: getattr(self, draw_f)())        # ТЕОРИЯ        self.txt_desc.config(state="normal")        self.txt_desc.delete("1.0", "end")        text = self.descriptions.get(name, "Описание отсутствует.")        for line in text.split('\n'):            if line.isupper() and len(line) > 3: self.txt_desc.insert("end", line + "\n", "header")            else: self.txt_desc.insert("end", line + "\n", "body")        self.txt_desc.config(state="disabled")    # --- UI HELPERS ---    def _add_inp(self, label, var, unit=""):        f = tb.Frame(self.input_frame); f.pack(fill="x", pady=2)        tb.Label(f, text=label, width=20, anchor="w").pack(side="left")        tb.Entry(f, textvariable=var).pack(side="left", fill="x", expand=True, padx=5)        tb.Label(f, text=unit, width=5).pack(side="left")        var.trace_add("write", lambda *args: self._do_calc())    def _add_btn(self):        tb.Button(self.input_frame, text="Рассчитать", command=self._do_calc, bootstyle="primary-outline").pack(fill="x", pady=10)    def _do_calc(self):        for cat in self.calculators.values():            if self.current_calc in cat:                func = cat[self.current_calc][2]                if hasattr(self, func):                    try: getattr(self, func)()                    except: pass                return    def _get(self, var):        try: return float(var.get().replace(",", "."))        except: return None    # --- BUILD UI ---    def build_ohm(self):        self._add_inp("Напряжение (U):", self.v1, "В"); self._add_inp("Сопротивление (R):", self.v2, "Ом"); self._add_btn()    def build_v_div(self):        self._add_inp("Вход (Uвх):", self.v1, "В"); self._add_inp("R1 (Верх):", self.v2, "Ом"); self._add_inp("R2 (Низ):", self.v3, "Ом"); self._add_btn()    def build_i_div(self):        self._add_inp("Ток (Iвх):", self.v1, "А"); self._add_inp("R1:", self.v2, "Ом"); self._add_inp("R2:", self.v3, "Ом"); self._add_btn()    def build_led(self):        self._add_inp("Питание (Uпит):", self.v1, "В"); self._add_inp("LED (Uпрям):", self.v2, "В"); self._add_inp("Ток (I):", self.v3, "мА"); self._add_btn()    def build_power(self):        self._add_inp("Напряжение:", self.v1, "В"); self._add_inp("Ток:", self.v2, "А"); self._add_btn()    def build_batt(self):        self._add_inp("Емкость:", self.v1, "мАч"); self._add_inp("Ток нагрузки:", self.v2, "мА"); self._add_btn()    def build_react(self):        self._add_inp("Частота:", self.v1, "Гц"); self._add_inp("L:", self.v2, "Гн"); self._add_inp("C:", self.v3, "Ф"); self._add_btn()    def build_reson(self):        self._add_inp("L:", self.v1, "Гн"); self._add_inp("C:", self.v2, "Ф"); self._add_btn()    def build_lambda(self):        self._add_inp("Частота:", self.v1, "МГц"); self._add_inp("Коэфф. (Vk):", self.v2, ""); self.v2.set("1.0"); self._add_btn()    def build_skin(self):        self._add_inp("Частота:", self.v1, "МГц"); f=tb.Frame(self.input_frame); f.pack(fill="x", pady=2)        tb.Label(f,text="Материал:",width=20,anchor="w").pack(side="left"); self.v2.set("Медь")        cb=tb.Combobox(f,textvariable=self.v2,values=["Медь", "Алюминий", "Золото"],state="readonly"); cb.pack(side="left",fill="x",expand=True)        cb.bind("<<ComboboxSelected>>", lambda e: self._do_calc()); self._add_btn()    def build_trace_r(self):        self._add_inp("Длина:", self.v1, "мм"); self._add_inp("Ширина:", self.v2, "мм"); self._add_inp("Толщина:", self.v3, "мкм"); self.v3.set("35"); self._add_btn()    def build_via(self):        self._add_inp("Диаметр:", self.v1, "мм"); self._add_inp("Покрытие:", self.v2, "мкм"); self.v2.set("25"); self._add_btn()    def build_rlc_comb(self):        f=tb.Frame(self.input_frame); f.pack(fill="x", pady=5); self.v3.set("Резисторы (R)")        cb=tb.Combobox(f,textvariable=self.v3,values=["Резисторы (R)", "Конденсаторы (C)", "Индуктивности (L)"],state="readonly"); cb.pack(fill="x")        cb.bind("<<ComboboxSelected>>", lambda e: self._do_calc())        self._add_inp("Значение 1:", self.v1); self._add_inp("Значение 2:", self.v2); self._add_btn()    def build_rc(self):        self._add_inp("R:", self.v1, "Ом"); self._add_inp("C:", self.v2, "мкФ"); self._add_btn()    def build_vswr(self):        self._add_inp("VSWR:", self.v1, ""); self._add_btn()    def build_noise(self):        self._add_inp("Темп (T):", self.v1, "K"); self._add_inp("Полоса:", self.v2, "МГц"); self._add_inp("R:", self.v3, "Ом"); self.v1.set("290"); self._add_btn()    def build_friis(self):        self._add_inp("Ptx:", self.v1, "dBm"); self._add_inp("Gtx:", self.v2, "dBi"); self._add_inp("Grx:", self.v3, "dBi"); self._add_inp("Freq:", self.v4, "МГц")        f=tb.Frame(self.input_frame); f.pack(fill="x",pady=2); tb.Label(f,text="Dist (km):",width=20,anchor="w").pack(side="left")        tb.Entry(f,textvariable=self.dist_var).pack(side="left",fill="x",expand=True); self.dist_var.trace_add("write", lambda *args: self._do_calc()); self._add_btn()    # --- CALC ---    def calc_ohm(self):        u,r=self._get(self.v1),self._get(self.v2)        if u and r: self.res1.set(f"I = {u/r:.4f} A"); self.res2.set(f"P = {u*u/r:.2f} Вт")    def calc_v_div(self):        v,r1,r2=self._get(self.v1),self._get(self.v2),self._get(self.v3)        if v and r1 and r2: self.res1.set(f"Uвых = {v*r2/(r1+r2):.3f} В")    def calc_i_div(self):        i,r1,r2=self._get(self.v1),self._get(self.v2),self._get(self.v3)        if i and r1 and r2: self.res1.set(f"I(R1)={i*r2/(r1+r2):.3f} A")    def calc_led(self):        vs,vf,i=self._get(self.v1),self._get(self.v2),self._get(self.v3)        if vs and vf and i: self.res1.set(f"R = {(vs-vf)/(i/1000):.1f} Ом")    def calc_power(self):        u,i=self._get(self.v1),self._get(self.v2)        if u and i: self.res1.set(f"P = {u*i:.2f} Вт")    def calc_batt(self):        c,i=self._get(self.v1),self._get(self.v2)        if c and i: self.res1.set(f"T ~ {(c/i)*0.85:.1f} ч")    def calc_react(self):        f,l,c=self._get(self.v1),self._get(self.v2),self._get(self.v3)        res=[]        if f and l: res.append(f"XL={2*math.pi*f*l:.1f} Ом")        if f and c: res.append(f"XC={1/(2*math.pi*f*c):.1f} Ом")        self.res1.set("\n".join(res))    def calc_reson(self):        l,c=self._get(self.v1),self._get(self.v2)        if l and c: self.res1.set(f"F = {1/(2*math.pi*math.sqrt(l*c)):.2f} Гц")    def calc_lambda(self):        f,k=self._get(self.v1),self._get(self.v2)        if f and k: self.res1.set(f"λ = {(299.79/f)*k:.3f} м")    def calc_skin(self):        f=self._get(self.v1)        if f:            rho=1.68e-8 if "Медь" in self.v2.get() else 2.44e-8            d=math.sqrt((2*rho)/(2*math.pi*f*1e6*4e-7*math.pi))            self.res1.set(f"δ = {d*1e6:.2f} мкм")    def calc_trace_r(self):        l,w,t=self._get(self.v1),self._get(self.v2),self._get(self.v3)        if l and w and t: r=1.68e-8*(l*1e-3)/((w*1e-3)*(t*1e-6)); self.res1.set(f"R = {r:.4f} Ом")    def calc_via(self):        d,t=self._get(self.v1),self._get(self.v2)        if d and t: self.res1.set(f"Imax ~ {math.pi*d*(t/1000)*100:.2f} A")    def calc_rc(self):        r,c=self._get(self.v1),self._get(self.v2)        if r and c: self.res1.set(f"τ = {r*c*1e-6:.4f} с")    def calc_vswr(self):        v=self._get(self.v1)        if v and v>=1: g=(v-1)/(v+1); self.res1.set(f"RL = {-20*math.log10(g):.2f} dB")    def calc_noise(self):        t,b,r=self._get(self.v1),self._get(self.v2),self._get(self.v3)        if t and b and r: v=math.sqrt(4*1.38e-23*t*b*1e6*r); self.res1.set(f"Vn = {v*1e6:.2f} мкВ")    def calc_friis(self):        pt,gt,gr,f=self._get(self.v1),self._get(self.v2),self._get(self.v3),self._get(self.v4)        d=self._get(self.dist_var)        if pt is not None and f and d:            loss=20*math.log10(d)+20*math.log10(f)+32.44            self.res1.set(f"Prx = {pt+gt+gr-loss:.1f} dBm")    def calc_rlc_comb(self):        v1,v2=self._get(self.v1),self._get(self.v2); mode=self.v3.get()        if v1 is not None and v2 is not None:            s,p = v1+v2, (v1*v2)/(v1+v2) if v1+v2!=0 else 0            if "Конд" in mode: s,p=p,s            self.res1.set(f"Посл: {s:.2f}"); self.res2.set(f"Паралл: {p:.2f}")    # =========================================================================    #                               ГРАФИЧЕСКИЙ ДВИЖОК (ГОСТ)    # =========================================================================    def _draw_resistor(self, c, x, y, orient="h", label="R"):        """ГОСТ: Прямоугольник 10x4 (в пикселях 40x14)"""        width = 2        w, h = 20, 7 # half-sizes        if orient == "h":            c.create_line(x-35, y, x-20, y, width=width) # Left wire            c.create_rectangle(x-20, y-7, x+20, y+7, width=width, outline="black", fill="white") # Body            c.create_line(x+20, y, x+35, y, width=width) # Right wire            if label: c.create_text(x, y-20, text=label, font=("Segoe UI", 9, "bold"))        else: # Vertical            c.create_line(x, y-35, x, y-20, width=width)            c.create_rectangle(x-7, y-20, x+7, y+20, width=width, outline="black", fill="white")            c.create_line(x, y+20, x, y+35, width=width)            if label: c.create_text(x+15, y, text=label, anchor="w", font=("Segoe UI", 9, "bold"))    def _draw_capacitor(self, c, x, y, orient="h", label="C"):        width=2        if orient == "h":            c.create_line(x-30, y, x-5, y, width=width)            c.create_line(x-5, y-15, x-5, y+15, width=width) # Plate 1            c.create_line(x+5, y-15, x+5, y+15, width=width) # Plate 2            c.create_line(x+5, y, x+30, y, width=width)            if label: c.create_text(x, y-22, text=label, font=("Segoe UI", 9, "bold"))        else:            c.create_line(x, y-30, x, y-5, width=width)            c.create_line(x-15, y-5, x+15, y-5, width=width)            c.create_line(x-15, y+5, x+15, y+5, width=width)            c.create_line(x, y+5, x, y+30, width=width)            if label: c.create_text(x+20, y, text=label, anchor="w", font=("Segoe UI", 9, "bold"))    def _draw_inductor(self, c, x, y, orient="h", label="L"):        width=2        if orient == "h":            c.create_line(x-30, y, x-20, y, width=width)            # 4 loops            for i in range(4):                c.create_arc(x-20 + i*10, y-10, x-10 + i*10, y+10, start=0, extent=180, style="arc", width=width)            c.create_line(x+20, y, x+30, y, width=width)            if label: c.create_text(x, y-15, text=label, font=("Segoe UI", 9, "bold"))        else:            c.create_line(x, y-30, x, y-20, width=width)            for i in range(4):                c.create_arc(x-10, y-20 + i*10, x+10, y-10 + i*10, start=90, extent=180, style="arc", width=width)            c.create_line(x, y+20, x, y+30, width=width)            if label: c.create_text(x+15, y, text=label, anchor="w", font=("Segoe UI", 9, "bold"))    def _draw_batt(self, c, x, y, label="V"):        c.create_line(x-30, y, x-5, y, width=2)        c.create_line(x-5, y-15, x-5, y+15, width=2) # Long (+)        c.create_line(x+5, y-8, x+5, y+8, width=4)   # Short (-)        c.create_line(x+5, y, x+30, y, width=2)        c.create_text(x-10, y-22, text="+", font=("Segoe UI", 10))        if label: c.create_text(x, y+25, text=label)    def _draw_gnd(self, c, x, y):        c.create_line(x, y, x, y+10, width=2)        c.create_line(x-15, y+10, x+15, y+10, width=2)        c.create_line(x-10, y+15, x+10, y+15, width=2)        c.create_line(x-5, y+20, x+5, y+20, width=2)    # --- SPECIFIC DIAGRAMS ---    def draw_ohm(self):        c = self.canvas; c.delete("all")        # Wire        c.create_line(100, 100, 300, 100, width=2)         c.create_line(100, 200, 300, 200, width=2)         c.create_line(100, 100, 100, 200, width=2)         c.create_line(300, 100, 300, 200, width=2)                 # Source        c.create_rectangle(90, 130, 110, 170, fill="white", outline="")        c.create_line(85, 140, 115, 140, width=2) # Long        c.create_line(95, 160, 105, 160, width=4) # Short        c.create_text(80, 140, text="+"); c.create_text(70, 150, text="U", font=("Segoe UI", 12, "bold"))                # Resistor (GOST)        c.create_rectangle(290, 120, 310, 180, fill="white", outline="")        self._draw_resistor(c, 300, 150, "v", "R")                # Arrow I        c.create_line(150, 100, 250, 100, arrow="last", fill="red", width=2)        c.create_text(200, 85, text="I", fill="red", font=("Segoe UI", 12, "bold"))    def draw_v_div(self):        c = self.canvas; c.delete("all")        cx = 200        c.create_line(cx, 50, cx, 250, width=2)        # R1        c.create_rectangle(cx-10, 80, cx+10, 120, fill="white", outline="")        self._draw_resistor(c, cx, 100, "v", "R1")        # R2        c.create_rectangle(cx-10, 180, cx+10, 220, fill="white", outline="")        self._draw_resistor(c, cx, 200, "v", "R2")                c.create_line(cx, 50, cx-50, 50, arrow="first", width=2); c.create_text(cx-70, 50, text="Uвх")        c.create_line(cx, 150, cx+50, 150, arrow="last", width=2); c.create_text(cx+70, 150, text="Uвых")        self._draw_gnd(c, cx, 250)    def draw_i_div(self):        c = self.canvas; c.delete("all")        c.create_line(50, 100, 350, 100, width=2)        c.create_line(150, 200, 250, 200, width=2)        # R1        c.create_line(150, 100, 150, 200, width=2)        c.create_rectangle(140, 130, 160, 170, fill="white", outline="")        self._draw_resistor(c, 150, 150, "v", "R1")        # R2        c.create_line(250, 100, 250, 200, width=2)        c.create_rectangle(240, 130, 260, 170, fill="white", outline="")        self._draw_resistor(c, 250, 150, "v", "R2")                c.create_line(50, 100, 100, 100, arrow="last", fill="red", width=2)        c.create_text(75, 80, text="I_общ", fill="red")    def draw_led(self):        c = self.canvas; c.delete("all")        c.create_text(50, 150, text="+Uпит", font=("Segoe UI", 10, "bold"))        c.create_line(80, 150, 120, 150, width=2)        self._draw_resistor(c, 150, 150, "h", "R")        c.create_line(180, 150, 220, 150, width=2)        c.create_line(220, 135, 220, 165, width=2)         c.create_polygon(220, 135, 250, 150, 220, 165, fill="#ff4444", outline="black")         c.create_line(250, 135, 250, 165, width=2)         c.create_line(230, 130, 245, 115, arrow="last", fill="#ff4444", width=2)        c.create_line(240, 130, 255, 115, arrow="last", fill="#ff4444", width=2)        c.create_line(250, 150, 300, 150, width=2)        self._draw_gnd(c, 300, 150)    def draw_react(self):        c = self.canvas; c.delete("all")        self._draw_inductor(c, 100, 150, "h", "L")        self._draw_capacitor(c, 300, 150, "h", "C")        c.create_text(200, 100, text="f (Частота)", font=("Segoe UI", 12))    def draw_reson(self):        c = self.canvas; c.delete("all")        c.create_line(100, 100, 300, 100, width=2)         c.create_line(100, 200, 300, 200, width=2)        c.create_line(150, 100, 150, 200, width=2)        c.create_rectangle(140, 130, 160, 170, fill="white", outline="")        self._draw_inductor(c, 150, 150, "v", "L")        c.create_line(250, 100, 250, 200, width=2)        c.create_rectangle(240, 130, 260, 170, fill="white", outline="")        self._draw_capacitor(c, 250, 150, "v", "C")    def draw_rlc_comb(self):        c = self.canvas; c.delete("all")        c.create_text(200, 50, text="Схема соединения", fill="gray")        self._draw_resistor(c, 100, 100, "h", "Z1")        self._draw_resistor(c, 200, 100, "h", "Z2")        c.create_text(150, 130, text="Последовательно", font=("Segoe UI", 9, "bold"))        y = 200        c.create_line(100, y-30, 100, y+30, width=2)        c.create_line(200, y-30, 200, y+30, width=2)        c.create_line(100, y-30, 200, y-30, width=2)        c.create_line(100, y+30, 200, y+30, width=2)        c.create_rectangle(130, y-40, 170, y-20, fill="white", outline="")        self._draw_resistor(c, 150, y-30, "h", "Z1")        c.create_rectangle(130, y+20, 170, y+40, fill="white", outline="")        self._draw_resistor(c, 150, y+30, "h", "Z2")        c.create_text(150, y+60, text="Параллельно", font=("Segoe UI", 9, "bold"))    def draw_rc(self):        c = self.canvas; c.delete("all")        c.create_line(50, 100, 150, 100, width=2)        self._draw_resistor(c, 100, 100, "h", "R")        c.create_line(150, 100, 250, 100, width=2)        c.create_line(200, 100, 200, 200, width=2)        c.create_rectangle(190, 130, 210, 170, fill="white", outline="")        self._draw_capacitor(c, 200, 150, "v", "C")        self._draw_gnd(c, 200, 200)    def draw_lambda(self):        c = self.canvas; c.delete("all")        c.create_line(50, 150, 350, 150, fill="gray", arrow="last")        points = []        for x in range(50, 330):            y = 150 - 50 * math.sin((x-50) * 0.05)            points.append(x); points.append(y)        c.create_line(points, smooth=True, width=2, fill="#007acc")        c.create_line(80, 100, 80+125, 100, arrow="both", fill="black")        c.create_text(80+60, 90, text="λ (Длина волны)", font=("Segoe UI", 10, "bold"))    def draw_skin(self):        c = self.canvas; c.delete("all")        cx, cy = 200, 150        r_out = 80; r_in = 60        c.create_oval(cx-r_out, cy-r_out, cx+r_out, cy+r_out, fill="#d87a48", outline="black", width=2)        c.create_oval(cx-r_in, cy-r_in, cx+r_in, cy+r_in, outline="white", dash=(4,2), width=2)        c.create_text(cx, cy, text="Проводник", font=("Segoe UI", 8))        c.create_line(cx+r_in, cy, cx+r_out, cy, arrow="both", fill="blue")        c.create_text(cx+r_out+20, cy, text="δ (Глубина)", fill="blue", font=("Segoe UI", 10, "bold"))    def draw_trace_r(self):        c = self.canvas; c.delete("all")        x, y, w, h, d = 100, 100, 200, 40, 30        c.create_rectangle(x, y, x+w, y+h, fill="#b87333", outline="black")        c.create_polygon(x, y, x+d, y-d, x+w+d, y-d, x+w, y, fill="#cd853f", outline="black")        c.create_polygon(x+w, y, x+w+d, y-d, x+w+d, y+h-d, x+w, y+h, fill="#8b4513", outline="black")        c.create_text(x+w/2, y+h+15, text="Длина (L)"); c.create_text(x-20, y+h/2, text="W"); c.create_text(x+w+d+20, y-d/2, text="T")    def draw_via(self):        c = self.canvas; c.delete("all")        cx = 200        c.create_oval(cx-50, 50, cx+50, 80, fill="gold", outline="black")        c.create_oval(cx-50, 200, cx+50, 230, fill="gold", outline="black")        c.create_line(cx-50, 65, cx-50, 215, width=2); c.create_line(cx+50, 65, cx+50, 215, width=2)        c.create_line(cx-50, 250, cx+50, 250, arrow="both")        c.create_text(cx, 265, text="Диаметр (d)")    def draw_friis(self):        c = self.canvas; c.delete("all")        c.create_polygon(50, 150, 80, 120, 20, 120, fill="gray", outline="black"); c.create_line(50, 150, 50, 200, width=2); c.create_text(50, 220, text="Прд (Tx)")        c.create_polygon(350, 150, 380, 120, 320, 120, fill="gray", outline="black"); c.create_line(350, 150, 350, 200, width=2); c.create_text(350, 220, text="Прм (Rx)")        for i in range(3): c.create_arc(60+i*20, 120-i*15, 100+i*20, 180+i*15, start=-45, extent=90, style="arc", outline="#007acc", width=2)    def draw_vswr(self):        c = self.canvas; c.delete("all")        c.create_line(50, 150, 350, 150, width=4, fill="#ddd")        c.create_line(100, 120, 180, 120, arrow="last", width=3, fill="green"); c.create_text(140, 100, text="Пад", fill="green")        c.create_line(250, 180, 170, 180, arrow="last", width=3, fill="red"); c.create_text(210, 200, text="Отр", fill="red")        c.create_rectangle(340, 130, 360, 170, fill="#555")    def draw_noise(self):        c = self.canvas; c.delete("all")        self._draw_resistor(c, 200, 150, "h", "R (Нагрет)")        pts = []        for x in range(100, 300, 5): pts.extend([x, 80 + random.randint(-10, 10)])        c.create_line(pts, fill="orange", width=1); c.create_text(200, 50, text="Тепловой шум", fill="orange")    def draw_batt(self):        c = self.canvas; c.delete("all")        self._draw_batt(c, 100, 150, "АКБ")        c.create_line(130, 150, 270, 150, width=2)        c.create_rectangle(270, 130, 320, 170, width=2)        c.create_text(295, 150, text="Нагрузка")        c.create_line(100, 150, 70, 150, width=2)        c.create_line(70, 150, 70, 250, 300, 250, 300, 170, width=2)        c.create_line(150, 140, 180, 140, arrow="last", fill="blue")        c.create_text(165, 125, text="I", fill="blue")    def draw_power(self):        self.draw_ohm()