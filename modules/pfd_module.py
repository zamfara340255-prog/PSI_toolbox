# -*- coding: utf-8 -*-import mathimport tkinter as tkimport tkinter.ttk as ttkfrom tkinter import messageboxfrom dataclasses import dataclassfrom core.utils import tb, C, MATPLOTLIB_OKfrom core.base_module import CalcModuleif MATPLOTLIB_OK:    from matplotlib.figure import Figure    from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk    from matplotlib.ticker import MultipleLocator@dataclassclass PFDInputs:    P_dbm: float    L_db: float    G_dbi: float    f_hz: float    Rref_m: float    Rtgt_m: float    norm_val: float    R_start_m: float    R_end_m: float    step_m: float    step_y: float    y_unit: strclass PowerFluxDensityModule(CalcModule):    key = "pfd"    title = "Плотность потока мощности (ППМ)"    def __init__(self, app):        super().__init__(app)        # --- Значения по умолчанию ---        self.var_P = tk.StringVar(value="-9")        self.var_L = tk.StringVar(value="6,2")        self.var_G = tk.StringVar(value="15")                self.var_f = tk.StringVar(value="10,7")        self.var_f_unit = tk.StringVar(value="ГГц")                self.var_Rref = tk.StringVar(value="3")        self.var_Rref_unit = tk.StringVar(value="м")                self.var_Rtgt = tk.StringVar(value="1500")        self.var_Rtgt_unit = tk.StringVar(value="м")                self.var_norm = tk.StringVar(value="-62")                # Настройки графика        self.var_R_start = tk.StringVar(value="0")        self.var_R_start_unit = tk.StringVar(value="м")                self.var_R_end = tk.StringVar(value="1500")        self.var_R_end_unit = tk.StringVar(value="м")                self.var_step = tk.StringVar(value="100")   # Шаг по X        self.var_step_y = tk.StringVar(value="5")   # Шаг по Y (Новое поле)                self.var_y_unit = tk.StringVar(value="дБВт/м²")        self.var_grid = tk.BooleanVar(value=True)        self.var_markers = tk.BooleanVar(value=True)        self.fig, self.ax, self.canvas = None, None, None        self._entries = {}         self._markers_list = []    def toolbar_actions(self):        return [            ("Рассчитать", "primary", self.calculate),            ("Обновить график", "success", self.update_plot),            ("Методика", "secondary", self.show_method),        ]    def build_ui(self, parent):        self.frame = tb.Frame(parent)        pad = 10                paned = ttk.PanedWindow(self.frame, orient='horizontal')        paned.pack(fill='both', expand=True)                left = tb.Frame(paned, padding=pad)        right = tb.Frame(paned, padding=pad)                paned.add(left, weight=0)         paned.add(right, weight=1)         # --- ЛЕВАЯ ПАНЕЛЬ: ВВОД ПАРАМЕТРОВ ---        c = tb.Labelframe(left, text="Параметры приемной системы", padding=pad)        c.pack(fill="x", pady=(0, pad))                def add_row(parent_fr, row, label_text, var, unit_var=None, units=None):            lbl = tb.Label(parent_fr, text=label_text, wraplength=250)            lbl.grid(row=row, column=0, sticky="w", pady=5)                        f = tb.Frame(parent_fr)            f.grid(row=row, column=1, sticky="e", pady=5)                        e = tb.Entry(f, textvariable=var, width=10)            e.pack(side="left")            self._entries[label_text] = e                        if unit_var and units:                cb = tb.Combobox(f, textvariable=unit_var, values=units, width=5, state="readonly")                cb.pack(side="left", padx=(5,0))        u_freq = ["Гц", "кГц", "МГц", "ГГц"]        u_dist = ["м", "см", "мм", "км"]        add_row(c, 0, "Измеренная мощность на входе (Pизм)", self.var_P)        add_row(c, 1, "Потери в тракте/кабеле (Lк)", self.var_L)        add_row(c, 2, "Коэфф. усиления антенны (G)", self.var_G)        add_row(c, 3, "Рабочая частота сигнала (f)", self.var_f, self.var_f_unit, u_freq)        add_row(c, 4, "Дистанция измерения (Rref)", self.var_Rref, self.var_Rref_unit, u_dist)        add_row(c, 5, "Дистанция расчета (Rtgt)", self.var_Rtgt, self.var_Rtgt_unit, u_dist)        add_row(c, 6, "Порог чувствительности (Norm)", self.var_norm)        # --- ЛЕВАЯ ПАНЕЛЬ: ГРАФИК ---        g = tb.Labelframe(left, text="Настройки построения", padding=pad)        g.pack(fill="x", pady=(0, pad))                add_row(g, 0, "Начало диапазона (R от)", self.var_R_start, self.var_R_start_unit, u_dist)        add_row(g, 1, "Конец диапазона (R до)", self.var_R_end, self.var_R_end_unit, u_dist)        add_row(g, 2, "Шаг сетки X (м)", self.var_step)                # Новое поле для шага по Y        tb.Label(g, text="Шаг сетки Y (уровень)").grid(row=3, column=0, sticky="w", pady=5)        tb.Entry(g, textvariable=self.var_step_y, width=10).grid(row=3, column=1, sticky="e", pady=5)                tb.Label(g, text="Единицы графика (Y)").grid(row=4, column=0, sticky="w", pady=5)        y_units = ["дБВт/м²", "Вт/м²", "мкВт/см²", "мВ/м (E-поле)"]        cb_y = tb.Combobox(g, textvariable=self.var_y_unit, values=y_units, state="readonly", width=15)        cb_y.grid(row=4, column=1, sticky="e")        cb_y.bind("<<ComboboxSelected>>", lambda e: self.update_plot())        # Чекбоксы        vis = tb.Frame(g)        vis.grid(row=5, column=0, columnspan=2, sticky="w", pady=10)                tb.Checkbutton(vis, text="Сетка", variable=self.var_grid, command=self.update_plot).pack(side="left", padx=(0,15))        tb.Checkbutton(vis, text="Маркеры (ЛКМ)", variable=self.var_markers).pack(side="left")                # Кнопка "Развернуть"        btn_exp = tb.Button(g, text="⤢ Развернуть график", command=self.open_detached, bootstyle="info-outline")        btn_exp.grid(row=6, column=0, columnspan=2, sticky="ew", pady=(10, 0))        # --- ПРАВАЯ ПАНЕЛЬ ---        res_fr = tb.Frame(right, padding=(0,0,0,10))        res_fr.pack(fill="x")        self.lbl_res = tb.Label(res_fr, text="—", font=("Segoe UI", 10), wraplength=800)        self.lbl_res.pack(anchor="w")        self.lbl_stat = tb.Label(res_fr, text="Статус: —", font=("Segoe UI", 11, "bold"))        self.lbl_stat.pack(anchor="w")        plot_cont = tb.Frame(right)        plot_cont.pack(fill="both", expand=True)        if MATPLOTLIB_OK:            self.fig = Figure(dpi=100)            self.ax = self.fig.add_subplot(111)            # Уменьшил левый отступ и нижний, чтобы влезло            self.fig.subplots_adjust(left=0.10, bottom=0.10, right=0.97, top=0.92)                        self.canvas = FigureCanvasTkAgg(self.fig, master=plot_cont)            self.canvas.get_tk_widget().pack(fill="both", expand=True)            self.toolbar = NavigationToolbar2Tk(self.canvas, plot_cont)            self.toolbar.update()                        self.canvas.mpl_connect("button_press_event", self.on_click)        else:            tb.Label(plot_cont, text="Matplotlib не установлен").pack()        return self.frame    # --- КОНВЕРТАЦИЯ ---    def _parse(self, val_str):        if not val_str or not val_str.strip(): return None        return float(val_str.replace(",", "."))    def _to_hz(self, val, unit):        u = unit.lower()        if u == "гц": return val        if u == "кгц": return val * 1e3        if u == "мгц": return val * 1e6        if u == "ггц": return val * 1e9        return val    def _to_m(self, val, unit):        u = unit.lower()        if u == "м": return val        if u == "см": return val / 100.0        if u == "мм": return val / 1000.0        if u == "км": return val * 1000.0        return val    def _read_data(self):        try:            d = PFDInputs(                P_dbm=self._parse(self.var_P.get()),                L_db=self._parse(self.var_L.get()),                G_dbi=self._parse(self.var_G.get()),                f_hz=self._to_hz(self._parse(self.var_f.get()), self.var_f_unit.get()),                Rref_m=self._to_m(self._parse(self.var_Rref.get()), self.var_Rref_unit.get()),                Rtgt_m=self._to_m(self._parse(self.var_Rtgt.get()), self.var_Rtgt_unit.get()),                norm_val=self._parse(self.var_norm.get()),                R_start_m=self._to_m(self._parse(self.var_R_start.get()), self.var_R_start_unit.get()),                R_end_m=self._to_m(self._parse(self.var_R_end.get()), self.var_R_end_unit.get()),                step_m=self._parse(self.var_step.get()),                step_y=self._parse(self.var_step_y.get()), # Читаем шаг по Y                y_unit=self.var_y_unit.get()            )            return d        except: return None    # --- МАТЕМАТИКА ---    def dbm_to_w(self, dbm): return 10**((dbm-30.0)/10.0)    def dbi_to_lin(self, dbi): return 10**(dbi/10.0)        def convert_s(self, val_dbwm2, unit):        if unit == "дБВт/м²": return val_dbwm2        val_wm2 = 10**(val_dbwm2/10.0)        if unit == "Вт/м²": return val_wm2        if unit == "мкВт/см²": return val_wm2 * 100.0         if unit == "мВ/м (E-поле)": return math.sqrt(val_wm2 * 376.73) * 1000.0        return val_dbwm2    def calculate_s_db(self, d: PFDInputs, r_m: float):        p_ant_dbm = d.P_dbm + d.L_db        p_ant_w = self.dbm_to_w(p_ant_dbm)        g_lin = self.dbi_to_lin(d.G_dbi)                numerator = 4.0 * math.pi * p_ant_w * (d.f_hz ** 2)        denominator = g_lin * (C ** 2)        s_at_measure_point = numerator / denominator                if d.Rref_m <= 0: return -999.0        val_wm2 = s_at_measure_point * ((d.Rref_m / r_m) ** 2)                if val_wm2 <= 0: return -999.0        return 10.0 * math.log10(val_wm2)    def calculate(self):        d = self._read_data()        if not d:            messagebox.showerror("Ошибка", "Проверьте введенные числа")            return                try:            s_ref_db = self.calculate_s_db(d, d.Rref_m)            s_tgt_db = self.calculate_s_db(d, d.Rtgt_m)            s_ref_disp = self.convert_s(s_ref_db, d.y_unit)            s_tgt_disp = self.convert_s(s_tgt_db, d.y_unit)                        status = "—"            color = "secondary"            if d.norm_val is not None:                if s_tgt_disp >= d.norm_val:                     status = "СООТВЕТСТВУЕТ (Сигнал достаточен)"                    color = "success"                else:                    status = "НЕ СООТВЕТСТВУЕТ (Сигнал ниже нормы)"                    color = "danger"            u = d.y_unit            res_txt = (f"S (на R={d.Rref_m} м) = {s_ref_disp:.4f} {u}\n"                       f"S (на R={d.Rtgt_m} м) = {s_tgt_disp:.4f} {u}")                        self.lbl_res.config(text=res_txt.replace("\n", "  |  "))            self.lbl_stat.config(text=status, bootstyle=color)            self.app.set_result(res_txt, status, color)            self.update_plot()                    except Exception as e:            messagebox.showerror("Ошибка расчета", str(e))    def update_plot(self):        if not MATPLOTLIB_OK or not self.ax: return        d = self._read_data()        if not d: return                try:            self.ax.clear()            self._markers_list = []                        xs = []            ys = []                        r = d.R_start_m            step = d.step_m            if step <= 0: step = 1.0            if r <= 0: r = step # Защита, чтобы не делить на 0                        # Генерация данных            while r <= d.R_end_m + (step*0.01):                val_db = self.calculate_s_db(d, r)                val_disp = self.convert_s(val_db, d.y_unit)                xs.append(r)                ys.append(val_disp)                r += step                        self.ax.plot(xs, ys, label="S(R)", linewidth=2, color="#0056b3")                        if d.norm_val is not None:                self.ax.axhline(d.norm_val, color='red', linestyle='--', label=f'Порог {d.norm_val}')                            if d.R_start_m <= d.Rtgt_m <= d.R_end_m:                val_tgt_db = self.calculate_s_db(d, d.Rtgt_m)                val_tgt = self.convert_s(val_tgt_db, d.y_unit)                self.ax.axvline(d.Rtgt_m, color='orange', linestyle=':', label='R цели')                self.ax.plot(d.Rtgt_m, val_tgt, 'o', color='orange')            # --- НАСТРОЙКА СЕТКИ (Grid) ---            self.ax.grid(self.var_grid.get(), which='major', alpha=0.7)            self.ax.grid(self.var_grid.get(), which='minor', alpha=0.3, linestyle=':')                        # Принудительная установка шага сетки            if d.step_m > 0:                self.ax.xaxis.set_major_locator(MultipleLocator(d.step_m))            if d.step_y and d.step_y > 0:                self.ax.yaxis.set_major_locator(MultipleLocator(d.step_y))                        self.ax.set_title("Зависимость плотности потока мощности S от расстояния R", fontsize=10)            self.ax.set_xlabel("Расстояние R, м", fontsize=9)            self.ax.set_ylabel(f"ППМ S, {d.y_unit}", fontsize=9)            self.ax.legend()                        # --- УБИРАЕМ ОТСТУПЫ (Margins) ---            # set_xlim устанавливает границы графика строго по данным            if xs:                self.ax.set_xlim(min(xs), max(xs))                        self.fig.tight_layout()            self.canvas.draw()                    except Exception as e:            print(f"Plot Error: {e}")    def on_click(self, event):        if not self.var_markers.get(): return        if event.inaxes != self.ax: return                if event.button == 1:             x = event.xdata            y = event.ydata            pt, = self.ax.plot(x, y, 'ro', markersize=5, zorder=10)            txt = self.ax.annotate(                f"R={x:.1f}\nS={y:.2f}", xy=(x, y), xytext=(10, 10),                 textcoords='offset points',                bbox=dict(boxstyle="round,pad=0.3", fc="yellow", alpha=0.7, ec="black"),                arrowprops=dict(arrowstyle="->", connectionstyle="arc3")            )            self._markers_list.append((pt, txt))            self.canvas.draw()                    elif event.button == 3:            if self._markers_list:                pt, txt = self._markers_list.pop()                pt.remove(); txt.remove()                self.canvas.draw()    def open_detached(self):        if not MATPLOTLIB_OK: return        win = tk.Toplevel(self.frame)        win.title("Детальный график ППМ")        win.geometry("900x600")        f = Figure(dpi=100)        a = f.add_subplot(111)                old_ax = self.ax        a.set_title(old_ax.get_title())        a.set_xlabel(old_ax.get_xlabel())        a.set_ylabel(old_ax.get_ylabel())        a.grid(True)                # Копируем линии        for line in old_ax.get_lines():            a.plot(line.get_xdata(), line.get_ydata(),                    color=line.get_color(), linestyle=line.get_linestyle(),                    label=line.get_label(), linewidth=2)                # Копируем границы осей (чтобы не было отступов и там)        a.set_xlim(old_ax.get_xlim())        a.set_ylim(old_ax.get_ylim())                a.legend()                c = FigureCanvasTkAgg(f, master=win)        c.get_tk_widget().pack(fill="both", expand=True)        NavigationToolbar2Tk(c, win)    def show_method(self):        msg = (            "МЕТОДИКА РАСЧЕТА (Прием):\n\n"            "1. Расчет плотности потока (S) в точке измерения:\n"            "   S = (4π · P_rx · f²) / (G · c²)\n\n"            "2. Пересчет на другую дистанцию:\n"            "   S(R) = S_ref · (R_ref / R)²"        )        messagebox.showinfo("Методика", msg)