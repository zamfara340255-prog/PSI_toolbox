# -*- coding: utf-8 -*-import mathimport tkinter as tkimport tkinter.ttk as ttkfrom tkinter import messageboxfrom dataclasses import dataclassfrom typing import Optionalfrom core.utils import tb, C, MATPLOTLIB_OKfrom core.base_module import CalcModuleif MATPLOTLIB_OK:    from matplotlib.figure import Figure    from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk    from matplotlib.ticker import MultipleLocator@dataclassclass PFDInputs:    P_dbm: float    L_db: float    G_dbi: float    f_hz: float    Rref_m: float    Rtgt_m: float    norm_val: float    # График настройки    R_start: float    R_end: float    Y_start: Optional[float]    Y_end: Optional[float]    # Шаги сетки    grid_step_x: float    grid_step_y: float    y_unit: strclass PowerFluxDensityModule(CalcModule):    key = "pfd"    title = "Плотность потока мощности (ППМ)"    def __init__(self, app):        super().__init__(app)        # --- Значения по умолчанию ---        self.var_P = tk.StringVar(value="-9")        self.var_L = tk.StringVar(value="6,2")        self.var_G = tk.StringVar(value="15")                self.var_f = tk.StringVar(value="10,7")        self.var_f_unit = tk.StringVar(value="ГГц")                self.var_Rref = tk.StringVar(value="3")        self.var_Rref_unit = tk.StringVar(value="м")                self.var_Rtgt = tk.StringVar(value="1500")        self.var_Rtgt_unit = tk.StringVar(value="м")                self.var_norm = tk.StringVar(value="-62")                # Настройки графика        self.var_R_start = tk.StringVar(value="0")        self.var_R_start_unit = tk.StringVar(value="м")        self.var_R_end = tk.StringVar(value="1500")        self.var_R_end_unit = tk.StringVar(value="м")                self.var_Y_start = tk.StringVar(value="") # Авто        self.var_Y_end = tk.StringVar(value="")   # Авто                self.var_grid_x = tk.StringVar(value="100") # Шаг сетки X        self.var_grid_y = tk.StringVar(value="5")   # Шаг сетки Y                self.var_y_unit = tk.StringVar(value="дБВт/м²")        self.var_grid = tk.BooleanVar(value=True)        self.var_markers = tk.BooleanVar(value=True)        self.fig, self.ax, self.canvas = None, None, None        self._entries = {}         self._markers_list = []    def toolbar_actions(self):        return [            ("Рассчитать", "primary", self.calculate),            ("Обновить график", "success", self.update_plot),            ("Методика", "secondary", self.show_method),        ]    def build_ui(self, parent):        self.frame = tb.Frame(parent)        pad = 10                paned = ttk.PanedWindow(self.frame, orient='horizontal')        paned.pack(fill='both', expand=True)                left = tb.Frame(paned, padding=pad)        right = tb.Frame(paned, padding=pad)                paned.add(left, weight=0)         paned.add(right, weight=1)         # --- ЛЕВАЯ ПАНЕЛЬ: ВВОД ---        c = tb.Labelframe(left, text="Параметры (Прием)", padding=pad)        c.pack(fill="x", pady=(0, pad))                def add_row(parent_fr, row, label_text, var, unit_var=None, units=None):            lbl = tb.Label(parent_fr, text=label_text, wraplength=250)            lbl.grid(row=row, column=0, sticky="w", pady=5)            f = tb.Frame(parent_fr)            f.grid(row=row, column=1, sticky="e", pady=5)            e = tb.Entry(f, textvariable=var, width=10)            e.pack(side="left")            if unit_var and units:                cb = tb.Combobox(f, textvariable=unit_var, values=units, width=5, state="readonly")                cb.pack(side="left", padx=(5,0))        u_freq = ["Гц", "кГц", "МГц", "ГГц"]        u_dist = ["м", "см", "мм", "км"]        add_row(c, 0, "Pизм (дБм)", self.var_P)        add_row(c, 1, "Lк (Потери, дБ)", self.var_L)        add_row(c, 2, "G (Усиление, дБи)", self.var_G)        add_row(c, 3, "Частота f", self.var_f, self.var_f_unit, u_freq)        add_row(c, 4, "R изм. (Rref)", self.var_Rref, self.var_Rref_unit, u_dist)        add_row(c, 5, "R цели (Rtgt)", self.var_Rtgt, self.var_Rtgt_unit, u_dist)        add_row(c, 6, "Норма (Порог)", self.var_norm)        # --- ЛЕВАЯ ПАНЕЛЬ: ГРАФИК ---        g = tb.Labelframe(left, text="Настройки графика", padding=pad)        g.pack(fill="x", pady=(0, pad))                # Диапазон X        add_row(g, 0, "Ось X: От", self.var_R_start, self.var_R_start_unit, u_dist)        add_row(g, 1, "Ось X: До", self.var_R_end, self.var_R_end_unit, u_dist)                # Диапазон Y        tb.Label(g, text="Ось Y: От / До").grid(row=2, column=0, sticky="w", pady=5)        fy = tb.Frame(g)        fy.grid(row=2, column=1, sticky="e")        tb.Entry(fy, textvariable=self.var_Y_start, width=7).pack(side="left")        tb.Label(fy, text="/").pack(side="left", padx=2)        tb.Entry(fy, textvariable=self.var_Y_end, width=7).pack(side="left")        # Шаги сетки        tb.Label(g, text="Шаг сетки: X / Y").grid(row=3, column=0, sticky="w", pady=5)        fg = tb.Frame(g)        fg.grid(row=3, column=1, sticky="e")        tb.Entry(fg, textvariable=self.var_grid_x, width=7).pack(side="left")        tb.Label(fg, text="/").pack(side="left", padx=2)        tb.Entry(fg, textvariable=self.var_grid_y, width=7).pack(side="left")        # Единицы        tb.Label(g, text="Единицы (Y)").grid(row=4, column=0, sticky="w", pady=5)        y_units = ["дБВт/м²", "Вт/м²", "мкВт/см²", "мВ/м (E-поле)"]        cb_y = tb.Combobox(g, textvariable=self.var_y_unit, values=y_units, state="readonly", width=15)        cb_y.grid(row=4, column=1, sticky="e")        cb_y.bind("<<ComboboxSelected>>", lambda e: self.update_plot())        # Кнопки        vis = tb.Frame(g)        vis.grid(row=5, column=0, columnspan=2, sticky="w", pady=10)        tb.Checkbutton(vis, text="Сетка", variable=self.var_grid, command=self.update_plot).pack(side="left", padx=(0,15))        tb.Checkbutton(vis, text="Маркеры", variable=self.var_markers).pack(side="left")                tb.Button(g, text="⤢ Развернуть график", command=self.open_detached, bootstyle="info-outline").grid(row=6, column=0, columnspan=2, sticky="ew")        # --- ПРАВАЯ ПАНЕЛЬ ---        res_fr = tb.Frame(right, padding=(0,0,0,10))        res_fr.pack(fill="x")        self.lbl_res = tb.Label(res_fr, text="—", font=("Segoe UI", 10), wraplength=800)        self.lbl_res.pack(anchor="w")        self.lbl_stat = tb.Label(res_fr, text="Статус: —", font=("Segoe UI", 11, "bold"))        self.lbl_stat.pack(anchor="w")        plot_cont = tb.Frame(right)        plot_cont.pack(fill="both", expand=True)        if MATPLOTLIB_OK:            self.fig = Figure(dpi=100)            self.ax = self.fig.add_subplot(111)            self.fig.subplots_adjust(left=0.10, bottom=0.10, right=0.97, top=0.92)                        self.canvas = FigureCanvasTkAgg(self.fig, master=plot_cont)            self.canvas.get_tk_widget().pack(fill="both", expand=True)            self.toolbar = NavigationToolbar2Tk(self.canvas, plot_cont)            self.toolbar.update()            self.canvas.mpl_connect("button_press_event", self.on_click)        else:            tb.Label(plot_cont, text="Matplotlib не установлен").pack()        # АВТОЗАПУСК РАСЧЕТА        self.calculate()        return self.frame    # --- ПАРСИНГ ---    def _parse(self, val_str):        if not val_str or not str(val_str).strip(): return None        try:            return float(str(val_str).replace(",", "."))        except ValueError:            return None # Не падаем при ошибке, возвращаем None    def _to_hz(self, val, unit):        if val is None: return 0.0        u = unit.lower()        if u == "гц": return val        if u == "кгц": return val * 1e3        if u == "мгц": return val * 1e6        if u == "ггц": return val * 1e9        return val    def _to_m(self, val, unit):        if val is None: return 0.0        u = unit.lower()        if u == "м": return val        if u == "см": return val / 100.0        if u == "мм": return val / 1000.0        if u == "км": return val * 1000.0        return val    def _read_data(self):        try:            # Парсим основные параметры (если ошибка - вернем None)            p = self._parse(self.var_P.get())            l = self._parse(self.var_L.get())            g = self._parse(self.var_G.get())            f = self._to_hz(self._parse(self.var_f.get()), self.var_f_unit.get())            rref = self._to_m(self._parse(self.var_Rref.get()), self.var_Rref_unit.get())            rtgt = self._to_m(self._parse(self.var_Rtgt.get()), self.var_Rtgt_unit.get())            norm = self._parse(self.var_norm.get())                        if p is None or f == 0 or rref == 0: return None            # Настройки графики (если ошибка - ставим дефолт)            r_start = self._to_m(self._parse(self.var_R_start.get()), self.var_R_start_unit.get())            r_end = self._to_m(self._parse(self.var_R_end.get()), self.var_R_end_unit.get())            if r_end <= r_start: r_end = r_start + 100                        y_start = self._parse(self.var_Y_start.get())            y_end = self._parse(self.var_Y_end.get())                        gx = self._parse(self.var_grid_x.get())            if gx is None or gx <= 0: gx = 100.0                        gy = self._parse(self.var_grid_y.get())            if gy is None or gy <= 0: gy = 5.0            # Шаг расчета делаем мелким для плавности            step_calc = (r_end - r_start) / 1000.0            if step_calc <= 0: step_calc = 1.0            return PFDInputs(                P_dbm=p, L_db=l if l else 0, G_dbi=g if g else 0, f_hz=f,                Rref_m=rref, Rtgt_m=rtgt, norm_val=norm,                R_start_m=r_start, R_end_m=r_end,                Y_start=y_start, Y_end=y_end,                grid_step_x=gx, grid_step_y=gy, step_m=step_calc,                y_unit=self.var_y_unit.get()            )        except Exception:             return None    # --- РАСЧЕТЫ ---    def dbm_to_w(self, dbm): return 10**((dbm-30.0)/10.0)    def dbi_to_lin(self, dbi): return 10**(dbi/10.0)        def convert_s(self, val_dbwm2, unit):        if unit == "дБВт/м²": return val_dbwm2        val_wm2 = 10**(val_dbwm2/10.0)        if unit == "Вт/м²": return val_wm2        if unit == "мкВт/см²": return val_wm2 * 100.0         if unit == "мВ/м (E-поле)": return math.sqrt(val_wm2 * 376.73) * 1000.0        return val_dbwm2    def calculate_s_db(self, d: PFDInputs, r_m: float):        # S(r) = S_meas * (R_meas / r)^2        # S_meas = (4pi * P * f^2) / (G * c^2)        p_ant_w = self.dbm_to_w(d.P_dbm + d.L_db)        g_lin = self.dbi_to_lin(d.G_dbi)        s_meas = (4.0 * math.pi * p_ant_w * (d.f_hz**2)) / (g_lin * (C**2))                if r_m <= 1e-6: r_m = 1e-6        s_r = s_meas * ((d.Rref_m / r_m)**2)        return 10.0 * math.log10(max(1e-20, s_r))    def calculate(self):        d = self._read_data()        if not d: return # Молча выходим, если данные не готовы                try:            s_ref = self.calculate_s_db(d, d.Rref_m)            s_tgt = self.calculate_s_db(d, d.Rtgt_m)                        s_ref_v = self.convert_s(s_ref, d.y_unit)            s_tgt_v = self.convert_s(s_tgt, d.y_unit)                        status, color = "—", "secondary"            if d.norm_val is not None:                # Если сигнал > нормы => ОК (для приема)                if s_tgt_v >= d.norm_val: status, color = "СООТВЕТСТВУЕТ (Сигнал есть)", "success"                else: status, color = "НЕ СООТВЕТСТВУЕТ (Слабый сигнал)", "danger"            u = d.y_unit            txt = f"S(R={d.Rref_m}м) = {s_ref_v:.4f} {u}  |  S(R={d.Rtgt_m}м) = {s_tgt_v:.4f} {u}"            self.lbl_res.config(text=txt)            self.lbl_stat.config(text=status, bootstyle=color)            self.update_plot()        except Exception as e:            messagebox.showerror("Ошибка", str(e))    def update_plot(self):        if not self.ax: return        d = self._read_data()        if not d: return                self.ax.clear()        self._markers_list = []                xs, ys = [], []        r = d.R_start_m        if r <= 0: r = 0.1 # Избегаем 0                while r <= d.R_end_m:            val = self.convert_s(self.calculate_s_db(d, r), d.y_unit)            xs.append(r); ys.append(val)            r += d.step_m                    self.ax.plot(xs, ys, label="S(R)", linewidth=2, color="#0056b3")                if d.norm_val is not None:            self.ax.axhline(d.norm_val, color='red', linestyle='--', label=f'Порог {d.norm_val}')                    if d.R_start_m <= d.Rtgt_m <= d.R_end_m:            val_tgt = self.convert_s(self.calculate_s_db(d, d.Rtgt_m), d.y_unit)            self.ax.axvline(d.Rtgt_m, color='orange', linestyle=':', label='Цель')            self.ax.plot(d.Rtgt_m, val_tgt, 'o', color='orange')        # --- СЕТКА И ДИАПАЗОНЫ ---        self.ax.grid(self.var_grid.get(), which='major', alpha=0.7)        self.ax.grid(self.var_grid.get(), which='minor', alpha=0.3, linestyle=':')                if d.grid_step_x > 0: self.ax.xaxis.set_major_locator(MultipleLocator(d.grid_step_x))        if d.grid_step_y > 0: self.ax.yaxis.set_major_locator(MultipleLocator(d.grid_step_y))                self.ax.set_xlim(d.R_start_m, d.R_end_m)        if d.Y_start is not None and d.Y_end is not None:            self.ax.set_ylim(d.Y_start, d.Y_end)                self.ax.set_xlabel("Расстояние R, м", fontsize=9)        self.ax.set_ylabel(f"S, {d.y_unit}", fontsize=9)        self.ax.legend()        self.fig.tight_layout()        self.canvas.draw()    def on_click(self, event):        if not self.var_markers.get() or event.inaxes != self.ax: return        if event.button == 1: # ЛКМ            x, y = event.xdata, event.ydata            pt, = self.ax.plot(x, y, 'ro', markersize=5)            txt = self.ax.annotate(f"R={x:.1f}\nS={y:.2f}", xy=(x,y), xytext=(10,10),                                    textcoords='offset points', bbox=dict(boxstyle="round", fc="yellow", alpha=0.7))            self._markers_list.append((pt, txt))            self.canvas.draw()        elif event.button == 3 and self._markers_list: # ПКМ            pt, txt = self._markers_list.pop()            pt.remove(); txt.remove()            self.canvas.draw()    def open_detached(self):        if not MATPLOTLIB_OK: return        win = tk.Toplevel(self.frame)        win.title("График ППМ")        win.geometry("900x600")        f = Figure(dpi=100)        a = f.add_subplot(111)                # Копируем свойства        old = self.ax        a.set_xlim(old.get_xlim()); a.set_ylim(old.get_ylim())        a.set_xlabel(old.get_xlabel()); a.set_ylabel(old.get_ylabel())        a.set_title(old.get_title()); a.grid(True)                for l in old.get_lines():            a.plot(l.get_xdata(), l.get_ydata(), color=l.get_color(), linestyle=l.get_linestyle(), label=l.get_label())                c = FigureCanvasTkAgg(f, master=win)        c.get_tk_widget().pack(fill="both", expand=True)        NavigationToolbar2Tk(c, win)    def show_method(self):        messagebox.showinfo("Инфо", "S = (4π·P·f²)/(G·c²)\nS(R) ~ 1/R²")