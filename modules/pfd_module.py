# -*- coding: utf-8 -*-import mathimport tkinter as tkimport tkinter.ttk as ttkfrom tkinter import messageboxfrom dataclasses import dataclassfrom core.utils import tb, MATPLOTLIB_OKfrom core.base_module import CalcModuleif MATPLOTLIB_OK:    from matplotlib.figure import Figure    from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk@dataclassclass PFDInputs:    P_dbm: float    L_db: float    G_dbi: float    f_hz: float    Rref_m: float    Rtgt_m: float    norm_val: float    R_start_m: float    R_end_m: float    step_m: float    y_unit: strclass PowerFluxDensityModule(CalcModule):    key = "pfd"    title = "Плотность потока мощности (ППМ)"    def __init__(self, app):        super().__init__(app)        # Значения по умолчанию        self.var_P = tk.StringVar(value="-9")        self.var_L = tk.StringVar(value="6,2")        self.var_G = tk.StringVar(value="15")                self.var_f = tk.StringVar(value="10,7")        self.var_f_unit = tk.StringVar(value="ГГц")                self.var_Rref = tk.StringVar(value="3")        self.var_Rref_unit = tk.StringVar(value="м")                self.var_Rtgt = tk.StringVar(value="1500")        self.var_Rtgt_unit = tk.StringVar(value="м")                self.var_norm = tk.StringVar(value="-62")                # График        self.var_R_start = tk.StringVar(value="1500")        self.var_R_start_unit = tk.StringVar(value="м")                self.var_R_end = tk.StringVar(value="2500")        self.var_R_end_unit = tk.StringVar(value="м")                self.var_step = tk.StringVar(value="50")        self.var_y_unit = tk.StringVar(value="дБВт/м²")        self.var_grid = tk.BooleanVar(value=True)        self.var_markers = tk.BooleanVar(value=False)        self.fig, self.ax, self.canvas = None, None, None        self._entries = {}     def toolbar_actions(self):        return [            ("Рассчитать", "primary", self.calculate),            ("Обновить график", "success", self.update_plot),            ("Развернуть график", "info", self.open_detached),            ("Методика", "secondary", self.show_method),        ]    def build_ui(self, parent):        self.frame = tb.Frame(parent)        pad = 10                # Разделение экрана        paned = ttk.PanedWindow(self.frame, orient='horizontal')        paned.pack(fill='both', expand=True)                left = tb.Frame(paned, padding=pad)        right = tb.Frame(paned, padding=pad)                # weight=0 для левой панели (фиксированная), weight=1 для правой (растягивается)        paned.add(left, weight=0)         paned.add(right, weight=1)         # --- ЛЕВАЯ ПАНЕЛЬ: ВВОД ---        c = tb.Labelframe(left, text="Параметры передатчика", padding=pad)        c.pack(fill="x", pady=(0, pad))                def add_row(parent_fr, row, label, var, unit_var=None, units=None):            tb.Label(parent_fr, text=label).grid(row=row, column=0, sticky="w", pady=5)            f = tb.Frame(parent_fr)            f.grid(row=row, column=1, sticky="w", pady=5)            e = tb.Entry(f, textvariable=var, width=10)            e.pack(side="left")            self._entries[label] = e            if unit_var and units:                cb = tb.Combobox(f, textvariable=unit_var, values=units, width=5, state="readonly")                cb.pack(side="left", padx=5)        add_row(c, 0, "Мощность Pизм (дБм)", self.var_P)        add_row(c, 1, "Потери в тракте Lк (дБ)", self.var_L)        add_row(c, 2, "Усиление G (дБи)", self.var_G)        add_row(c, 3, "Частота f", self.var_f, self.var_f_unit, ["Гц", "кГц", "МГц", "ГГц"])        add_row(c, 4, "R измерения (Rref)", self.var_Rref, self.var_Rref_unit, ["м", "см", "мм"])        add_row(c, 5, "R цели (Rtgt)", self.var_Rtgt, self.var_Rtgt_unit, ["м", "см", "мм"])        add_row(c, 6, "Норма (Slimit)", self.var_norm)        # --- ЛЕВАЯ ПАНЕЛЬ: ГРАФИК ---        g = tb.Labelframe(left, text="Настройки графика", padding=pad)        g.pack(fill="x", pady=(0, pad))                add_row(g, 0, "R начало", self.var_R_start, self.var_R_start_unit, ["м", "см", "мм"])        add_row(g, 1, "R конец", self.var_R_end, self.var_R_end_unit, ["м", "см", "мм"])        add_row(g, 2, "Шаг (м)", self.var_step)                tb.Label(g, text="Единицы оси Y").grid(row=3, column=0, sticky="w", pady=5)        tb.Combobox(g, textvariable=self.var_y_unit, values=["дБВт/м²", "Вт/м²"], state="readonly", width=12).grid(row=3, column=1, sticky="w")        vis = tb.Frame(g)        vis.grid(row=4, column=0, columnspan=2, sticky="w", pady=5)        tb.Checkbutton(vis, text="Сетка", variable=self.var_grid).pack(side="left", padx=(0,10))        tb.Checkbutton(vis, text="Маркеры (ЛКМ)", variable=self.var_markers).pack(side="left")        # --- ПРАВАЯ ПАНЕЛЬ: РЕЗУЛЬТАТ ---        res_fr = tb.Frame(right, padding=(0,0,0,10))        res_fr.pack(fill="x")        self.lbl_res = tb.Label(res_fr, text="—", font=("Segoe UI", 10), wraplength=600)        self.lbl_res.pack(anchor="w")        self.lbl_stat = tb.Label(res_fr, text="Статус: —", font=("Segoe UI", 11, "bold"))        self.lbl_stat.pack(anchor="w")        plot_cont = tb.Frame(right)        plot_cont.pack(fill="both", expand=True)        if MATPLOTLIB_OK:            self.fig = Figure(dpi=100)            self.ax = self.fig.add_subplot(111)            # ОТСТУПЫ (Margins), чтобы текст не обрезался            self.fig.subplots_adjust(left=0.15, bottom=0.15, right=0.95, top=0.92)                        self.canvas = FigureCanvasTkAgg(self.fig, master=plot_cont)            self.canvas.get_tk_widget().pack(fill="both", expand=True)            self.toolbar = NavigationToolbar2Tk(self.canvas, plot_cont)            self.toolbar.update()                        self.canvas.mpl_connect("button_press_event", self.on_click)        else:            tb.Label(plot_cont, text="Библиотека matplotlib не найдена").pack()        return self.frame    # --- Парсинг и конвертация ---    def _parse(self, val_str):        if not val_str or not val_str.strip(): return None        return float(val_str.replace(",", "."))    def _to_hz(self, val, unit):        u = unit.lower()        if u == "гц": return val        if u == "кгц": return val * 1e3        if u == "мгц": return val * 1e6        if u == "ггц": return val * 1e9        return val    def _to_m(self, val, unit):        u = unit.lower()        if u == "м": return val        if u == "см": return val / 100.0        if u == "мм": return val / 1000.0        return val    def _read_data(self):        try:            d = PFDInputs(                P_dbm=self._parse(self.var_P.get()),                L_db=self._parse(self.var_L.get()),                G_dbi=self._parse(self.var_G.get()),                f_hz=self._to_hz(self._parse(self.var_f.get()), self.var_f_unit.get()),                Rref_m=self._to_m(self._parse(self.var_Rref.get()), self.var_Rref_unit.get()),                Rtgt_m=self._to_m(self._parse(self.var_Rtgt.get()), self.var_Rtgt_unit.get()),                norm_val=self._parse(self.var_norm.get()),                R_start_m=self._to_m(self._parse(self.var_R_start.get()), self.var_R_start_unit.get()),                R_end_m=self._to_m(self._parse(self.var_R_end.get()), self.var_R_end_unit.get()),                step_m=self._parse(self.var_step.get()),                y_unit=self.var_y_unit.get()            )            return d        except Exception:            return None    def dbm_to_w(self, dbm): return 10**((dbm-30.0)/10.0)    def dbi_to_lin(self, dbi): return 10**(dbi/10.0)    def db_to_wm2(self, db): return 10**(db/10.0)    def calculate_s_db(self, d: PFDInputs, r_m: float):        p_ant_dbm = d.P_dbm + d.L_db         p_ant_w = self.dbm_to_w(p_ant_dbm)        g_lin = self.dbi_to_lin(d.G_dbi)        eirp_w = p_ant_w * g_lin        s_wm2 = eirp_w / (4.0 * math.pi * (r_m**2))        return 10.0 * math.log10(s_wm2)    def calculate(self):        d = self._read_data()        if not d:            messagebox.showerror("Ошибка", "Проверьте введенные числа")            return                # ВОТ ЗДЕСЬ БЫЛА ОШИБКА У ТЕБЯ В КОНСОЛИ        try:            s_ref = self.calculate_s_db(d, d.Rref_m)            s_tgt = self.calculate_s_db(d, d.Rtgt_m)                        status = "—"            color = "secondary"            if d.norm_val is not None:                if s_tgt <= d.norm_val:                     status = "СООТВЕТСТВУЕТ НОРМЕ"                    color = "success"                else:                    status = "НЕ СООТВЕТСТВУЕТ"                    color = "danger"            res_txt = (f"S (на {d.Rref_m} м) = {s_ref:.3f} дБВт/м²\n"                       f"S (на {d.Rtgt_m} м) = {s_tgt:.3f} дБВт/м²")                        self.lbl_res.config(text=res_txt.replace("\n", "  |  "))            self.lbl_stat.config(text=status, bootstyle=color)            self.app.set_result(res_txt, status, color)                        self.update_plot()                    except Exception as e:            messagebox.showerror("Ошибка расчета", str(e))    def update_plot(self):        if not MATPLOTLIB_OK or not self.ax: return        d = self._read_data()        if not d: return                try:            self.ax.clear()            xs = []            ys = []            r = d.R_start_m            if d.step_m <= 0: d.step_m = 1.0                        # Цикл построения точек            while r <= d.R_end_m:                val_db = self.calculate_s_db(d, r)                val = val_db if d.y_unit == "дБВт/м²" else self.db_to_wm2(val_db)                xs.append(r)                ys.append(val)                r += d.step_m                        self.ax.plot(xs, ys, label="S(R)", linewidth=2)                        if d.norm_val is not None:                nv = d.norm_val if d.y_unit == "дБВт/м²" else self.db_to_wm2(d.norm_val)                self.ax.axhline(nv, color='red', linestyle='--', label=f'Норма {nv:.1f}')                            if d.R_start_m <= d.Rtgt_m <= d.R_end_m:                self.ax.axvline(d.Rtgt_m, color='orange', linestyle=':', label='R цели')            self.ax.grid(self.var_grid.get())            self.ax.set_xlabel("Расстояние R, м")            self.ax.set_ylabel(f"ППМ S, {d.y_unit}")            self.ax.legend()                        # --- ФИКС ОБРЕЗКИ ГРАФИКА (margins) ---            if xs:                span_x = max(xs) - min(xs)                margin_x = span_x * 0.05 if span_x > 0 else 1.0                self.ax.set_xlim(min(xs) - margin_x, max(xs) + margin_x)                                span_y = max(ys) - min(ys)                margin_y = span_y * 0.1 if span_y > 0 else 1.0                self.ax.set_ylim(min(ys) - margin_y, max(ys) + margin_y)            self.canvas.draw()                    except Exception as e:            pass     def on_click(self, event):        if not self.var_markers.get(): return        if event.button == 1 and event.xdata:            self.ax.plot(event.xdata, event.ydata, 'ro')            self.ax.annotate(f"{event.ydata:.2f}", (event.xdata, event.ydata), xytext=(5,5), textcoords='offset points')            self.canvas.draw()    def open_detached(self):        if not MATPLOTLIB_OK: return        win = tk.Toplevel(self.frame)        win.title("ППМ График")        win.geometry("900x600")        f = Figure(dpi=100)        a = f.add_subplot(111)        if self.ax.lines:            l = self.ax.lines[0]            a.plot(l.get_xdata(), l.get_ydata())            a.set_xlabel(self.ax.get_xlabel())            a.set_ylabel(self.ax.get_ylabel())            a.grid(True)        c = FigureCanvasTkAgg(f, master=win)        c.get_tk_widget().pack(fill="both", expand=True)        NavigationToolbar2Tk(c, win)    def show_method(self):        messagebox.showinfo("Методика", "Расчет в свободном пространстве:\nS = (P_tx * G) / (4 * pi * R^2)")