# -*- coding: utf-8 -*-import mathimport tkinter as tkimport tkinter.ttk as ttkfrom tkinter import messagebox, simpledialog  # Добавили simpledialogfrom dataclasses import dataclassfrom typing import Optionalfrom core.utils import tb, C, MATPLOTLIB_OKfrom core.base_module import CalcModuleif MATPLOTLIB_OK:    from matplotlib.figure import Figure    from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk    from matplotlib.ticker import MultipleLocator@dataclassclass PFDInputs:    P_dbm: float    L_db: float    G_dbi: float    f_hz: float    Rref_m: float    Rtgt_m: float    norm_val: float    R_start_m: float    R_end_m: float    step_m: float    step_y: float    y_unit: str    y_min: Optional[float]    y_max: Optional[float]class PowerFluxDensityModule(CalcModule):    key = "pfd"    title = "Плотность потока мощности (ППМ)"    def __init__(self, app):        super().__init__(app)        # --- Дефолтные значения ---        self.var_P = tk.StringVar(value="-9")        self.var_L = tk.StringVar(value="6.5")        self.var_G = tk.StringVar(value="15")        self.var_f = tk.StringVar(value="10.7")        self.var_f_unit = tk.StringVar(value="ГГц")        self.var_Rref = tk.StringVar(value="3")        self.var_Rref_unit = tk.StringVar(value="м")        self.var_Rtgt = tk.StringVar(value="1500")        self.var_Rtgt_unit = tk.StringVar(value="м")        self.var_norm = tk.StringVar(value="-62")                # Настройки графика        self.var_R_start = tk.StringVar(value="0")        self.var_R_start_unit = tk.StringVar(value="м")        self.var_R_end = tk.StringVar(value="1500")        self.var_R_end_unit = tk.StringVar(value="м")        self.var_step = tk.StringVar(value="100")         self.var_step_y = tk.StringVar(value="5")                self.var_y_min = tk.StringVar(value="")        self.var_y_max = tk.StringVar(value="")        self.var_y_unit = tk.StringVar(value="дБВт/м²")        self.var_markers = tk.BooleanVar(value=True)        # Переменные для вывода результата        self.var_lbl_ref = tk.StringVar(value="ППМ на дистанции замера:")        self.var_res_ref = tk.StringVar(value="—")        self.var_lbl_tgt = tk.StringVar(value="ППМ на дистанции до цели:")        self.var_res_tgt = tk.StringVar(value="—")        self.var_status_text = tk.StringVar(value="Ожидание расчета")                self.fig, self.ax, self.canvas = None, None, None        self._entries = {}         self._markers_list = []    def toolbar_actions(self):        return []    def build_ui(self, parent):        self.frame = tb.Frame(parent)        pad = 10                paned = ttk.PanedWindow(self.frame, orient='horizontal')        paned.pack(fill='both', expand=True)                left = tb.Frame(paned, padding=pad)        right = tb.Frame(paned, padding=pad)                paned.add(left, weight=0)         paned.add(right, weight=1)         # --- ЛЕВАЯ ПАНЕЛЬ: ВВОД ---        c = tb.Labelframe(left, text="Параметры системы", padding=pad)        c.pack(fill="x", pady=(0, pad))                def add_row(parent_fr, row, label_text, var, unit_var=None, units=None):            lbl = tb.Label(parent_fr, text=label_text, wraplength=220, font=("Segoe UI", 9))            lbl.grid(row=row, column=0, sticky="w", pady=5)            f = tb.Frame(parent_fr)            f.grid(row=row, column=1, sticky="e", pady=5)            e = tb.Entry(f, textvariable=var, width=8, font=("Segoe UI", 9))            e.pack(side="left")            self._entries[label_text] = e            if unit_var and units:                cb = tb.Combobox(f, textvariable=unit_var, values=units, width=5, state="readonly", font=("Segoe UI", 9))                cb.pack(side="left", padx=(5,0))        u_freq = ["Гц", "кГц", "МГц", "ГГц"]        u_dist = ["м", "см", "мм", "км"]        add_row(c, 0, "Мощность на входе (P)", self.var_P)        add_row(c, 1, "Потери в тракте (L)", self.var_L)        add_row(c, 2, "Коэфф. усиления (G)", self.var_G)        add_row(c, 3, "Рабочая частота (f)", self.var_f, self.var_f_unit, u_freq)        add_row(c, 4, "Дистанция замера (Rref)", self.var_Rref, self.var_Rref_unit, u_dist)        add_row(c, 5, "Дистанция до цели (Rtgt)", self.var_Rtgt, self.var_Rtgt_unit, u_dist)        add_row(c, 6, "Пороговый уровень (Norm)", self.var_norm)        # --- ЛЕВАЯ ПАНЕЛЬ: НАСТРОЙКИ ГРАФИКА ---        g = tb.Labelframe(left, text="Настройки графика", padding=pad)        g.pack(fill="x", pady=(0, pad))                add_row(g, 0, "R начало", self.var_R_start, self.var_R_start_unit, u_dist)        add_row(g, 1, "R конец", self.var_R_end, self.var_R_end_unit, u_dist)        add_row(g, 2, "Шаг по оси X", self.var_step)                tb.Label(g, text="Шаг по оси Y", font=("Segoe UI", 9)).grid(row=3, column=0, sticky="w", pady=5)        tb.Entry(g, textvariable=self.var_step_y, width=8, font=("Segoe UI", 9)).grid(row=3, column=1, sticky="e", pady=5)                tb.Label(g, text="Min Y (авто)", font=("Segoe UI", 9)).grid(row=4, column=0, sticky="w", pady=5)        tb.Entry(g, textvariable=self.var_y_min, width=8, font=("Segoe UI", 9)).grid(row=4, column=1, sticky="e", pady=5)        tb.Label(g, text="Max Y (авто)", font=("Segoe UI", 9)).grid(row=5, column=0, sticky="w", pady=5)        tb.Entry(g, textvariable=self.var_y_max, width=8, font=("Segoe UI", 9)).grid(row=5, column=1, sticky="e", pady=5)        tb.Label(g, text="Единицы измерения Y", font=("Segoe UI", 9)).grid(row=6, column=0, sticky="w", pady=5)        y_units = ["дБВт/м²", "Вт/м²", "мкВт/см²", "мВ/м (E-поле)"]        cb_y = tb.Combobox(g, textvariable=self.var_y_unit, values=y_units, state="readonly", width=14, font=("Segoe UI", 8))        cb_y.grid(row=6, column=1, sticky="e")        cb_y.bind("<<ComboboxSelected>>", lambda e: self.update_plot())        tb.Checkbutton(g, text="Маркеры (ЛКМ)", variable=self.var_markers).grid(row=7, column=0, columnspan=2, sticky="w", pady=5)        # --- ЛЕВАЯ ПАНЕЛЬ: ДЕЙСТВИЯ ---        act = tb.Labelframe(left, text="Управление", padding=pad)        act.pack(fill="x", pady=(0, pad))        btn_fr = tb.Frame(act)        btn_fr.pack(fill="x")                tb.Button(btn_fr, text="Рассчитать", command=self.calculate, bootstyle="primary").pack(fill="x", pady=2)        tb.Button(btn_fr, text="Обновить график", command=self.update_plot, bootstyle="success").pack(fill="x", pady=2)        tb.Button(btn_fr, text="Методика расчета", command=self.show_method, bootstyle="info-outline").pack(fill="x", pady=2)        # --- РЕЗУЛЬТАТЫ ---        res_frame = tb.Labelframe(left, text="Результаты расчета", padding=10, bootstyle="default")        res_frame.pack(fill="x", pady=(0, pad))        tb.Label(res_frame, textvariable=self.var_lbl_ref, font=("Segoe UI", 9), bootstyle="secondary").pack(anchor="w", pady=(0,2))        tb.Label(res_frame, textvariable=self.var_res_ref, font=("Segoe UI", 12, "bold"), bootstyle="primary").pack(anchor="w", pady=(0, 8))        tb.Label(res_frame, textvariable=self.var_lbl_tgt, font=("Segoe UI", 9), bootstyle="secondary").pack(anchor="w", pady=(0,2))        tb.Label(res_frame, textvariable=self.var_res_tgt, font=("Segoe UI", 12, "bold"), bootstyle="primary").pack(anchor="w", pady=(0, 10))        self.lbl_status = tb.Label(res_frame, textvariable=self.var_status_text,                                    font=("Segoe UI", 10, "bold"), anchor="center", bootstyle="inverse-secondary")        self.lbl_status.pack(fill="x", ipady=5)        # --- ПРАВАЯ ПАНЕЛЬ ---        plot_cont = tb.Frame(right)        plot_cont.pack(fill="both", expand=True)        if MATPLOTLIB_OK:            self.fig = Figure(dpi=100)            self.ax = self.fig.add_subplot(111)            self.fig.subplots_adjust(left=0.10, bottom=0.10, right=0.97, top=0.92)                        self.canvas = FigureCanvasTkAgg(self.fig, master=plot_cont)            self.canvas.get_tk_widget().pack(fill="both", expand=True)            self.toolbar = NavigationToolbar2Tk(self.canvas, plot_cont)            self.toolbar.update()                        self.canvas.mpl_connect("button_press_event", self.on_click)        else:            tb.Label(plot_cont, text="Matplotlib не установлен").pack()        return self.frame    # --- ЛОГИКА ---    def _parse(self, val_str):        if not val_str or not val_str.strip(): return None        return float(val_str.replace(",", "."))    def _parse_opt(self, val_str):        if not val_str or not val_str.strip(): return None        try: return float(val_str.replace(",", "."))        except ValueError: return None    def _to_hz(self, val, unit):        u = unit.lower()        if u == "ггц": return val * 1e9        if u == "мгц": return val * 1e6        if u == "кгц": return val * 1e3        return val    def _to_m(self, val, unit):        u = unit.lower()        if u == "км": return val * 1000.0        if u == "см": return val / 100.0        if u == "мм": return val / 1000.0        return val    def _read_data(self):        try:            return PFDInputs(                P_dbm=self._parse(self.var_P.get()),                L_db=self._parse(self.var_L.get()),                G_dbi=self._parse(self.var_G.get()),                f_hz=self._to_hz(self._parse(self.var_f.get()), self.var_f_unit.get()),                Rref_m=self._to_m(self._parse(self.var_Rref.get()), self.var_Rref_unit.get()),                Rtgt_m=self._to_m(self._parse(self.var_Rtgt.get()), self.var_Rtgt_unit.get()),                norm_val=self._parse(self.var_norm.get()),                R_start_m=self._to_m(self._parse(self.var_R_start.get()), self.var_R_start_unit.get()),                R_end_m=self._to_m(self._parse(self.var_R_end.get()), self.var_R_end_unit.get()),                step_m=self._parse(self.var_step.get()),                step_y=self._parse(self.var_step_y.get()),                y_unit=self.var_y_unit.get(),                y_min=self._parse_opt(self.var_y_min.get()),                y_max=self._parse_opt(self.var_y_max.get())            )        except: return None    def dbm_to_w(self, dbm): return 10**((dbm-30.0)/10.0)    def dbi_to_lin(self, dbi): return 10**(dbi/10.0)        def convert_s(self, val_dbwm2, unit):        if unit == "дБВт/м²": return val_dbwm2        val_wm2 = 10**(val_dbwm2/10.0)        if unit == "Вт/м²": return val_wm2        if unit == "мкВт/см²": return val_wm2 * 100.0         if unit == "мВ/м (E-поле)": return math.sqrt(val_wm2 * 376.73) * 1000.0        return val_dbwm2    def calculate_s_db(self, d: PFDInputs, r_m: float):        p_ant_dbm = d.P_dbm + d.L_db        p_ant_w = self.dbm_to_w(p_ant_dbm)        g_lin = self.dbi_to_lin(d.G_dbi)        numerator = 4.0 * math.pi * p_ant_w * (d.f_hz ** 2)        denominator = g_lin * (C ** 2)        s_at_measure_point = numerator / denominator        if d.Rref_m <= 0: return -999.0        val_wm2 = s_at_measure_point * ((d.Rref_m / r_m) ** 2)        if val_wm2 <= 0: return -999.0        return 10.0 * math.log10(val_wm2)    def calculate(self):        d = self._read_data()        if not d:            messagebox.showerror("Ошибка", "Проверьте числа")            return                try:            s_ref_db = self.calculate_s_db(d, d.Rref_m)            s_tgt_db = self.calculate_s_db(d, d.Rtgt_m)            s_ref_disp = self.convert_s(s_ref_db, d.y_unit)            s_tgt_disp = self.convert_s(s_tgt_db, d.y_unit)                        u = d.y_unit            self.var_lbl_ref.set(f"ППМ на дистанции {d.Rref_m} м:")            self.var_res_ref.set(f"{s_ref_disp:.2f} {u}")            self.var_lbl_tgt.set(f"ППМ на дистанции {d.Rtgt_m} м:")            self.var_res_tgt.set(f"{s_tgt_disp:.2f} {u}")            if d.norm_val is not None:                if s_tgt_disp >= d.norm_val:                     self.var_status_text.set("СООТВЕТСТВУЕТ")                    self.lbl_status.config(bootstyle="success-inverse")                else:                    self.var_status_text.set("НЕ СООТВЕТСТВУЕТ")                    self.lbl_status.config(bootstyle="danger-inverse")                        self.update_plot()                    except Exception as e:            messagebox.showerror("Ошибка", str(e))    def update_plot(self):        if not MATPLOTLIB_OK or not self.ax: return        d = self._read_data()        if not d: return                try:            self.ax.clear()            self._markers_list = []                        xs, ys = [], []            r = d.R_start_m            step = d.step_m if d.step_m > 0 else 1.0            if r <= 0: r = step                        while r <= d.R_end_m + (step*0.01):                val_db = self.calculate_s_db(d, r)                val_disp = self.convert_s(val_db, d.y_unit)                xs.append(r)                ys.append(val_disp)                r += step                        self.ax.plot(xs, ys, label="S(R)", linewidth=2, color="#0056b3")                        if d.norm_val is not None:                self.ax.axhline(d.norm_val, color='red', linestyle='--', label=f'Порог {d.norm_val}')                            if d.R_start_m <= d.Rtgt_m <= d.R_end_m:                val_tgt_db = self.calculate_s_db(d, d.Rtgt_m)                val_tgt = self.convert_s(val_tgt_db, d.y_unit)                self.ax.plot(d.Rtgt_m, val_tgt, 'o', color='orange', label="Цель")            self.ax.grid(True, which='major', alpha=0.7)            self.ax.grid(True, which='minor', alpha=0.3, linestyle=':')            self.ax.minorticks_on()                        if d.step_m > 0: self.ax.xaxis.set_major_locator(MultipleLocator(d.step_m))            if d.step_y and d.step_y > 0: self.ax.yaxis.set_major_locator(MultipleLocator(d.step_y))                        self.ax.set_title("Зависимость ППМ от расстояния")            self.ax.set_xlabel("Расстояние R, м")            self.ax.set_ylabel(f"S, {d.y_unit}")            self.ax.legend()                        if xs: self.ax.set_xlim(min(xs), max(xs))            if d.y_min is not None: self.ax.set_ylim(bottom=d.y_min)            if d.y_max is not None: self.ax.set_ylim(top=d.y_max)            self.fig.tight_layout()            self.canvas.draw()                    except Exception as e:            print(f"Plot Error: {e}")    def on_click(self, event):        # 1. ОБРАБОТКА ДВОЙНОГО ЩЕЛЧКА (ПЕРЕИМЕНОВАНИЕ)        if event.dblclick:            clicked_obj = None            name_obj = ""                        # Проверяем, попал ли клик в заголовок или оси            if self.ax.title.contains(event)[0]:                clicked_obj = self.ax.title                name_obj = "заголовка графика"            elif self.ax.xaxis.label.contains(event)[0]:                clicked_obj = self.ax.xaxis.label                name_obj = "подписи оси X"            elif self.ax.yaxis.label.contains(event)[0]:                clicked_obj = self.ax.yaxis.label                name_obj = "подписи оси Y"                            if clicked_obj:                new_text = simpledialog.askstring("Переименование",                                                   f"Введите новый текст для {name_obj}:",                                                   initialvalue=clicked_obj.get_text(),                                                  parent=self.frame)                if new_text is not None:                    clicked_obj.set_text(new_text)                    self.canvas.draw()            return # Если двойной клик, маркер не ставим        # 2. ОБРАБОТКА МАРКЕРОВ (Одиночный клик)        if not self.var_markers.get(): return        if event.inaxes != self.ax: return                if event.button == 1:             x, y = event.xdata, event.ydata            pt, = self.ax.plot(x, y, 'ro', markersize=5, zorder=10)            txt = self.ax.annotate(                f"{x:.1f}; {y:.2f}", xy=(x, y), xytext=(10, 10),                 textcoords='offset points', bbox=dict(boxstyle="round,pad=0.3", fc="#ffffe0", alpha=0.9),                arrowprops=dict(arrowstyle="->"))            self._markers_list.append((pt, txt))            self.canvas.draw()        elif event.button == 3:            if self._markers_list:                pt, txt = self._markers_list.pop()                pt.remove(); txt.remove()                self.canvas.draw()    def show_method(self):        msg = (            "МЕТОДИКА ОЦЕНКИ ПЛОТНОСТИ ПОТОКА МОЩНОСТИ\n\n"            "Расчет основан на определении Эквивалентной Изотропно Излучаемой Мощности (ЭИИМ) "            "и модели распространения радиоволн в свободном пространстве (Free Space Path Loss).\n\n"            "1. Расчет ЭИИМ (EIRP):\n"            "   EIRP [Вт] = P_tx [Вт] · G_tx [раз] / L_loss [раз]\n"            "   (учитывается мощность передатчика, усиление антенны и потери в тракте).\n\n"            "2. Плотность потока мощности S на расстоянии R:\n"            "   В условиях дальней зоны (Far Field) плотность потока определяется как отношение "            "излучаемой мощности к площади сферы радиусом R:\n\n"            "   S = EIRP / (4 · π · R²)\n\n"            "3. Пересчет для произвольной дистанции:\n"            "   Поскольку S обратно пропорциональна квадрату расстояния:\n"            "   S(R_tgt) = S(R_ref) · (R_ref / R_tgt)²"        )        messagebox.showinfo("Методика расчета", msg)