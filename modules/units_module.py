# -*- coding: utf-8 -*-import tkinter as tkfrom core.utils import tbfrom core.base_module import CalcModuleclass UnitConverterModule(CalcModule):    key = "units"    title = "Конвертер единиц"    def __init__(self, app):        super().__init__(app)        self.var_category = tk.StringVar(value="Мощность")        self.var_value = tk.StringVar(value="1")        self.var_from = tk.StringVar(value="Вт")        self.var_to = tk.StringVar(value="кВт")        self.var_result = tk.StringVar(value="")        # Полный список категорий        self._cats = {            "Мощность": [("Вт", 1.0), ("мВт", 1e-3), ("кВт", 1e3), ("МВт", 1e6), ("дБм", "dbm"), ("дБВт", "dbw")],            "Ёмкость": [("Ф", 1.0), ("мФ", 1e-3), ("мкФ", 1e-6), ("нФ", 1e-9), ("пФ", 1e-12)],            "Сопротивление": [("Ом", 1.0), ("мОм", 1e-3), ("кОм", 1e3), ("МОм", 1e6)],            "Индуктивность": [("Гн", 1.0), ("мГн", 1e-3), ("мкГн", 1e-6), ("нГн", 1e-9)],            "Время": [("с", 1.0), ("мс", 1e-3), ("мкс", 1e-6), ("нс", 1e-9), ("мин", 60.0), ("ч", 3600.0), ("сут", 86400.0)],            "Давление": [("Па", 1.0), ("кПа", 1e3), ("МПа", 1e6), ("бар", 1e5), ("атм", 101325.0), ("мм рт. ст.", 133.322), ("psi", 6894.76)],            "Частота": [("Гц", 1.0), ("кГц", 1e3), ("МГц", 1e6), ("ГГц", 1e9)],            "Длина": [("м", 1.0), ("см", 0.01), ("мм", 0.001), ("км", 1000.0), ("дюйм", 0.0254)]        }    def toolbar_actions(self):        return [            ("Рассчитать", "primary", self.convert),            ("Поменять местами", "secondary", self.swap),        ]    def build_ui(self, parent):        self.frame = tb.Frame(parent)        pad = 12        left = tb.Labelframe(self.frame, text="Параметры перевода", padding=pad)        left.pack(side="left", fill="y", padx=(0, pad))        tb.Label(left, text="Раздел").grid(row=0, column=0, sticky="w", pady=6)        cb_cat = tb.Combobox(left, textvariable=self.var_category, values=list(self._cats.keys()), state="readonly", width=26)        cb_cat.grid(row=0, column=1, sticky="w", pady=6)        tb.Label(left, text="Значение").grid(row=1, column=0, sticky="w", pady=6)        tb.Entry(left, textvariable=self.var_value, width=18).grid(row=1, column=1, sticky="w", pady=6)        tb.Label(left, text="Из").grid(row=2, column=0, sticky="w", pady=6)        cb_from = tb.Combobox(left, textvariable=self.var_from, state="readonly", width=26)        cb_from.grid(row=2, column=1, sticky="w", pady=6)        tb.Label(left, text="В").grid(row=3, column=0, sticky="w", pady=6)        cb_to = tb.Combobox(left, textvariable=self.var_to, state="readonly", width=26)        cb_to.grid(row=3, column=1, sticky="w", pady=6)        right = tb.Labelframe(self.frame, text="Результат", padding=pad)        right.pack(side="left", fill="both", expand=True)        tb.Label(right, text="Результат").pack(anchor="w")        tb.Entry(right, textvariable=self.var_result, state="readonly", font=("Segoe UI", 14)).pack(fill="x", pady=(6, 12))        def refresh_units(*_):            cat = self.var_category.get()            vals = [u for (u, _) in self._cats[cat]]            cb_from.configure(values=vals)            cb_to.configure(values=vals)            if self.var_from.get() not in vals: self.var_from.set(vals[0])            if self.var_to.get() not in vals: self.var_to.set(vals[min(1, len(vals)-1)])        cb_cat.bind("<<ComboboxSelected>>", refresh_units)        refresh_units()                left.columnconfigure(1, weight=1)        return self.frame    def swap(self):        a = self.var_from.get()        b = self.var_to.get()        self.var_from.set(b)        self.var_to.set(a)        self.convert()    def _to_si(self, cat: str, value: float, unit: str) -> float:        for u, k in self._cats[cat]:            if u != unit: continue            if k == "dbm": return 10 ** ((value - 30.0) / 10.0)            if k == "dbw": return 10 ** (value / 10.0)            return value * float(k)        return value    def _from_si(self, cat: str, si_value: float, unit: str) -> float:        import math        for u, k in self._cats[cat]:            if u != unit: continue            if k == "dbm": return 10.0 * math.log10(si_value / 1e-3) if si_value > 0 else float("-inf")            if k == "dbw": return 10.0 * math.log10(si_value) if si_value > 0 else float("-inf")            return si_value / float(k)        return si_value    def convert(self):        try:            v = float(self.var_value.get().replace(",", ".").strip())            cat = self.var_category.get()            u_from = self.var_from.get()            u_to = self.var_to.get()            si = self._to_si(cat, v, u_from)            out = self._from_si(cat, si, u_to)                        if abs(out) >= 1e6 or (abs(out) > 0 and abs(out) < 1e-3):                res_str = f"{out:.6e}"            else:                res_str = f"{out:.6f}".rstrip("0").rstrip(".")            self.var_result.set(f"{res_str} {u_to}")            self.app.set_result(f"{v} {u_from} -> {res_str} {u_to}", "Готово", "success")        except Exception as e:            self.var_result.set("Ошибка")            self.app.set_result(str(e), "Ошибка", "danger")