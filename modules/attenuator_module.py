# -*- coding: utf-8 -*-import tkinter as tkimport mathfrom core.utils import tbfrom core.base_module import CalcModule# Стандартные ряды резисторовE24 = [1.0, 1.1, 1.2, 1.3, 1.5, 1.6, 1.8, 2.0, 2.2, 2.4, 2.7, 3.0, 3.3, 3.6, 3.9, 4.3, 4.7, 5.1, 5.6, 6.2, 6.8, 7.5, 8.2, 9.1]E96 = [    1.00, 1.02, 1.05, 1.07, 1.10, 1.13, 1.15, 1.18, 1.21, 1.24, 1.27, 1.30, 1.33, 1.37, 1.40, 1.43, 1.47, 1.50, 1.54, 1.58, 1.62, 1.65, 1.69, 1.74, 1.78, 1.82, 1.87, 1.91, 1.96,     2.00, 2.05, 2.10, 2.15, 2.21, 2.26, 2.32, 2.37, 2.43, 2.49, 2.55, 2.61, 2.67, 2.74, 2.80, 2.87, 2.94,     3.01, 3.09, 3.16, 3.24, 3.32, 3.40, 3.48, 3.57, 3.65, 3.74, 3.83, 3.92,     4.02, 4.12, 4.22, 4.32, 4.42, 4.53, 4.64, 4.75, 4.87, 4.99,     5.11, 5.23, 5.36, 5.49, 5.62, 5.76, 5.90,     6.04, 6.19, 6.34, 6.49, 6.65, 6.81, 6.98,     7.15, 7.32, 7.50, 7.68, 7.87,     8.06, 8.25, 8.45, 8.66, 8.87,     9.09, 9.31, 9.53, 9.76]class AttenuatorModule(CalcModule):    key = "attenuator"    title = "Расчет аттенюаторов"    def __init__(self, app):        super().__init__(app)                # Режим расчета: 0 = Прямой (dB -> R), 1 = Обратный (R -> dB)        self.var_mode = tk.IntVar(value=0)        # Параметры        self.var_db = tk.StringVar(value="6")              self.var_z0 = tk.StringVar(value="50")        self.var_series = tk.StringVar(value="Точные") # Выбор ряда E24/E96        self.var_type = tk.StringVar(value="П-образный (Pi)")                 # Результаты параметров (для режима 1)        self.var_z_in_res = tk.StringVar(value="-")        self.var_z_out_res = tk.StringVar(value="-")                # Резисторы        self.var_r1 = tk.StringVar(value="-")         self.var_r2 = tk.StringVar(value="-")         self.var_r3 = tk.StringVar(value="-")                 # Хранение рассчитанных стандартных значений        self._std_r1 = None        self._std_r2 = None        self._std_r3 = None                self.canvas = None        self.entries_resistors = []     def toolbar_actions(self):        return []    def build_ui(self, parent):        self.frame = tb.Frame(parent)        pad = 20                paned = tb.Frame(self.frame)        paned.pack(fill="both", expand=True, padx=pad, pady=pad)                left = tb.Labelframe(paned, text="Параметры сигнала", padding=20)        left.pack(side="left", fill="y", padx=(0, 20))                right = tb.Labelframe(paned, text="Схема и номиналы", padding=20)        right.pack(side="right", fill="both", expand=True)        # --- ЛЕВАЯ ЧАСТЬ ---        tb.Label(left, text="Режим работы:", font=("Segoe UI", 10, "bold")).pack(anchor="w", pady=(0, 5))        tb.Radiobutton(left, text="Найти резисторы (по dB)", variable=self.var_mode, value=0, command=self.toggle_mode).pack(anchor="w")        tb.Radiobutton(left, text="Найти параметры (по R)", variable=self.var_mode, value=1, command=self.toggle_mode).pack(anchor="w", pady=(0, 15))        tb.Label(left, text="Тип схемы:", font=("Segoe UI", 10)).pack(anchor="w", pady=(0, 5))        cb_type = tb.Combobox(left, textvariable=self.var_type, values=["П-образный (Pi)", "Т-образный (Tee)"], state="readonly", font=("Segoe UI", 11))        cb_type.pack(fill="x", pady=(0, 15))        cb_type.bind("<<ComboboxSelected>>", lambda e: self.calculate())        # Контейнер для ввода параметров (чтобы менять содержимое)        self.fr_mode_content = tb.Frame(left)        self.fr_mode_content.pack(fill="x")        # --- ПРАВАЯ ЧАСТЬ ---        self.canvas = tk.Canvas(right, bg="white", height=300, bd=0, highlightthickness=0)        self.canvas.pack(fill="x", pady=(0, 20))                res_grid = tb.Frame(right)        res_grid.pack(fill="x")                # Поля резисторов        self.lbl_r1, self.ent_r1 = self.create_res_field(res_grid, "R1", self.var_r1)        self.lbl_r2, self.ent_r2 = self.create_res_field(res_grid, "R2", self.var_r2)        self.lbl_r3, self.ent_r3 = self.create_res_field(res_grid, "R3", self.var_r3)        self.entries_resistors = [self.ent_r1, self.ent_r2, self.ent_r3]        # Инициализация        self.toggle_mode()        self.calculate()        return self.frame    def create_res_field(self, parent, label, var):        f = tb.Frame(parent, borderwidth=1, relief="solid", padding=10, bootstyle="secondary")        f.pack(side="left", fill="x", expand=True, padx=5)        lbl = tb.Label(f, text=label, font=("Segoe UI", 10, "bold"))        lbl.pack()        ent = tb.Entry(f, textvariable=var, font=("Consolas", 12, "bold"), justify="center")        ent.pack(fill="x")        return lbl, ent    def toggle_mode(self):        # Очищаем динамическую зону слева        for widget in self.fr_mode_content.winfo_children():            widget.destroy()        mode = self.var_mode.get()                if mode == 0: # --- ПРЯМОЙ РЕЖИМ (dB -> R) ---            # Ввод параметров            tb.Label(self.fr_mode_content, text="Импеданс (Z0), Ом:", font=("Segoe UI", 10)).pack(anchor="w")            self.ent_z0 = tb.Combobox(self.fr_mode_content, textvariable=self.var_z0, values=["50", "75", "600"], font=("Segoe UI", 11))            self.ent_z0.pack(fill="x", pady=(0, 10))                        tb.Label(self.fr_mode_content, text="Затухание (dB):", font=("Segoe UI", 10)).pack(anchor="w")            self.ent_db = tb.Entry(self.fr_mode_content, textvariable=self.var_db, font=("Segoe UI", 11))            self.ent_db.pack(fill="x", pady=(0, 10))            # Выбор ряда            tb.Label(self.fr_mode_content, text="Подбор номиналов:", font=("Segoe UI", 10)).pack(anchor="w")            cb_series = tb.Combobox(self.fr_mode_content, textvariable=self.var_series, values=["Точные", "E24 (5%)", "E96 (1%)"], state="readonly", font=("Segoe UI", 11))            cb_series.pack(fill="x", pady=(0, 15))            cb_series.bind("<<ComboboxSelected>>", lambda e: self.calculate())            # Кнопка применения (будет показана кодом, если расчет успешен)            self.btn_apply_std = tb.Button(self.fr_mode_content, text="↓ Применить номиналы", command=self.apply_standard_values, bootstyle="success-outline")                        # Блокируем поля резисторов справа            for e in self.entries_resistors:                e.configure(state="readonly", bootstyle="default")        else: # --- ОБРАТНЫЙ РЕЖИМ (R -> dB) ---            # Результаты (только чтение)            res_box = tb.Frame(self.fr_mode_content, bootstyle="secondary", padding=15)            res_box.pack(fill="x", pady=(0, 15))                        tb.Label(res_box, text="Результат расчета:", font=("Segoe UI", 10, "bold"), bootstyle="inverse-secondary").pack(anchor="w")            tb.Label(res_box, textvariable=self.var_db, font=("Consolas", 18, "bold"), bootstyle="inverse-secondary").pack(anchor="w", pady=(5,0))            tb.Label(res_box, text="Затухание (dB)", font=("Segoe UI", 8), bootstyle="inverse-secondary").pack(anchor="w", pady=(0,10))                        tb.Label(res_box, textvariable=self.var_z_in_res, bootstyle="inverse-secondary").pack(anchor="w")            tb.Label(res_box, textvariable=self.var_z_out_res, bootstyle="inverse-secondary").pack(anchor="w")            # Разблокируем поля резисторов справа            for e in self.entries_resistors:                e.configure(state="normal", bootstyle="success")        # Общая кнопка "Рассчитать"        tb.Button(self.fr_mode_content, text="РАССЧИТАТЬ", command=self.calculate, bootstyle="primary").pack(fill="x", ipady=5)    def _get_val(self, var):        try: return float(var.get().replace(",", ".").split()[0])         except: return None    def _find_nearest_std(self, value, series_name):        if value <= 0 or value == float('inf'): return value        series = E24 if "E24" in series_name else E96                try:            exponent = math.floor(math.log10(value))            mantissa = value / (10 ** exponent)            # Находим ближайшее в списке            nearest = min(series, key=lambda x: abs(x - mantissa))            return nearest * (10 ** exponent)        except:            return value    def apply_standard_values(self):        """Переносит стандартные значения в режим ввода"""        if self._std_r1 and self._std_r2 and self._std_r3:            self.var_mode.set(1)            self.toggle_mode()            self.var_r1.set(str(self._std_r1))            self.var_r2.set(str(self._std_r2))            self.var_r3.set(str(self._std_r3))            self.calculate()    def calculate(self):        mode = self.var_mode.get()        topo = self.var_type.get()        series_mode = self.var_series.get()        is_pi = "Pi" in topo                try:            # === РЕЖИМ 0: ИЩЕМ РЕЗИСТОРЫ ===            if mode == 0:                dB = self._get_val(self.var_db)                Z0 = self._get_val(self.var_z0)                                if dB is None or Z0 is None or dB < 0: return                                K = 10 ** (dB / 20.0)                if K == 1:                     self.var_r1.set("∞" if is_pi else "0")                    self.var_r2.set("0" if is_pi else "∞")                    self.var_r3.set("∞" if is_pi else "0")                    return                # Точные                if is_pi:                    r_shunt = Z0 * (K + 1) / (K - 1)                    r_series = Z0 * (K**2 - 1) / (2 * K)                    r1_exact, r2_exact, r3_exact = r_shunt, r_series, r_shunt                else:                    r_series = Z0 * (K - 1) / (K + 1)                    r_shunt = Z0 * (2 * K) / (K**2 - 1)                    r1_exact, r2_exact, r3_exact = r_series, r_shunt, r_series                # Подбор ряда                if "E24" in series_mode or "E96" in series_mode:                    r1_std = self._find_nearest_std(r1_exact, series_mode)                    r2_std = self._find_nearest_std(r2_exact, series_mode)                    r3_std = r1_std                                         self.var_r1.set(f"{r1_exact:.1f} → {r1_std} Ω")                    self.var_r2.set(f"{r2_exact:.1f} → {r2_std} Ω")                    self.var_r3.set(f"{r3_exact:.1f} → {r3_std} Ω")                                        self._std_r1, self._std_r2, self._std_r3 = r1_std, r2_std, r3_std                                        # Показываем кнопку "Применить"                    if hasattr(self, 'btn_apply_std'):                        self.btn_apply_std.pack(pady=(5, 10), fill="x", before=self.fr_mode_content.winfo_children()[-1])                 else:                    self.var_r1.set(f"{r1_exact:.2f}")                    self.var_r2.set(f"{r2_exact:.2f}")                    self.var_r3.set(f"{r3_exact:.2f}")                    if hasattr(self, 'btn_apply_std'):                        self.btn_apply_std.pack_forget()                self.lbl_r1.config(text="R1 (Шунт)" if is_pi else "R1 (Послед.)")                self.lbl_r2.config(text="R2 (Послед.)" if is_pi else "R2 (Шунт)")                self.lbl_r3.config(text="R3 (Шунт)" if is_pi else "R3 (Послед.)")                                # Рисуем точную схему (для наглядности)                self.draw_pi_pad(r1_exact, r2_exact, r3_exact) if is_pi else self.draw_tee_pad(r1_exact, r2_exact, r3_exact)            # === РЕЖИМ 1: ИЩЕМ ПАРАМЕТРЫ ===            else:                R1 = self._get_val(self.var_r1)                R2 = self._get_val(self.var_r2)                R3 = self._get_val(self.var_r3)                                if R1 is None or R2 is None or R3 is None: return                if is_pi:                    if R1 == 0 or R3 == 0: return                     A = 1 + R2 / R3                    B = R2                    C = (1/R1) + (1/R3) + (R2 / (R1 * R3))                    D = 1 + R2 / R1                    self.draw_pi_pad(R1, R2, R3)                    self.lbl_r1.config(text="R1 (Шунт)")                    self.lbl_r2.config(text="R2 (Послед.)")                    self.lbl_r3.config(text="R3 (Шунт)")                else:                    if R3 == 0: return                    A = 1 + R1 / R3                    B = R1 + R2 + (R1 * R2) / R3                    C = 1 / R3                    D = 1 + R2 / R3                    self.draw_tee_pad(R1, R2, R3)                    self.lbl_r1.config(text="R1 (Послед.)")                    self.lbl_r2.config(text="R2 (Шунт)")                    self.lbl_r3.config(text="R3 (Послед.)")                Z_in = math.sqrt((A * B) / (C * D))                Z_out = math.sqrt((D * B) / (C * A))                Gamma = math.sqrt(A * D) + math.sqrt(B * C)                dB = 20 * math.log10(Gamma)                                self.var_db.set(f"{dB:.2f}")                                if abs(Z_in - Z_out) < 0.1:                    self.var_z_in_res.set(f"Импеданс Z0: {Z_in:.2f} Ом")                    self.var_z_out_res.set("(Симметричный)")                else:                    self.var_z_in_res.set(f"Вход Z: {Z_in:.2f} Ом")                    self.var_z_out_res.set(f"Выход Z: {Z_out:.2f} Ом")        except Exception as e:            print(f"Calc Error: {e}")    # --- РИСОВАНИЕ ---    def draw_resistor(self, x, y, orientation="h", label="R"):        w, h = 60, 20        c = self.canvas        if orientation == "v":            w, h = 20, 60            c.create_rectangle(x-w/2, y, x+w/2, y+h, fill="#fff", outline="black", width=2)            c.create_text(x+45, y+h/2, text=label, font=("Segoe UI", 10, "bold"), fill="#0056b3", anchor="w")        else:            c.create_rectangle(x, y-h/2, x+w, y+h/2, fill="#fff", outline="black", width=2)            c.create_text(x+w/2, y-40, text=label, font=("Segoe UI", 10, "bold"), fill="#0056b3")        return w, h    def draw_line(self, x1, y1, x2, y2):        self.canvas.create_line(x1, y1, x2, y2, width=2, fill="black")    def draw_dot(self, x, y):        r = 4        self.canvas.create_oval(x-r, y-r, x+r, y+r, fill="black")    def draw_pi_pad(self, r1_val, r2_val, r3_val):        c = self.canvas        c.delete("all")        mid_y, gnd_y = 100, 220        x_in, x_n1, x_n2, x_out = 50, 120, 280, 350                self.draw_line(x_in, mid_y, x_n1, mid_y)        c.create_text(x_in, mid_y-20, text="Вход", font=("Segoe UI", 10))                # R2 (Series)        self.draw_line(x_n1, mid_y, x_n1 + 40, mid_y)         self.draw_resistor(x_n1 + 40, mid_y, "h", f"R2\n{r2_val:.1f}Ω")        self.draw_line(x_n1 + 40 + 60, mid_y, x_n2, mid_y)                self.draw_line(x_n2, mid_y, x_out, mid_y)        c.create_text(x_out, mid_y-20, text="Выход", font=("Segoe UI", 10))                # R1 (Shunt Left)        self.draw_line(x_n1, mid_y, x_n1, mid_y + 30)        self.draw_resistor(x_n1, mid_y + 30, "v", f"R1\n{r1_val:.1f}Ω")        self.draw_line(x_n1, mid_y + 30 + 60, x_n1, gnd_y)                # R3 (Shunt Right)        self.draw_line(x_n2, mid_y, x_n2, mid_y + 30)        self.draw_resistor(x_n2, mid_y + 30, "v", f"R3\n{r3_val:.1f}Ω")        self.draw_line(x_n2, mid_y + 30 + 60, x_n2, gnd_y)                self.draw_line(x_in, gnd_y, x_out, gnd_y)        self.draw_dot(x_n1, mid_y); self.draw_dot(x_n2, mid_y)        self.draw_dot(x_n1, gnd_y); self.draw_dot(x_n2, gnd_y)        c.create_text(x_in + (x_out-x_in)/2, gnd_y + 20, text="Общий (GND)", fill="gray", font=("Segoe UI", 9))    def draw_tee_pad(self, r1_val, r2_val, r3_val):        c = self.canvas        c.delete("all")        mid_y, gnd_y = 100, 220        x_in, center_x, x_out = 50, 200, 350                # R1 (Left Series)        self.draw_line(x_in, mid_y, x_in + 30, mid_y)        self.draw_resistor(x_in + 30, mid_y, "h", f"R1\n{r1_val:.1f}Ω")        self.draw_line(x_in + 30 + 60, mid_y, center_x, mid_y)        c.create_text(x_in, mid_y-20, text="Вход", font=("Segoe UI", 10))                # R3 (Right Series)        self.draw_line(center_x, mid_y, center_x + 30, mid_y)        self.draw_resistor(center_x + 30, mid_y, "h", f"R3\n{r3_val:.1f}Ω")        self.draw_line(center_x + 30 + 60, mid_y, x_out, mid_y)        c.create_text(x_out, mid_y-20, text="Выход", font=("Segoe UI", 10))                # R2 (Center Shunt)        self.draw_line(center_x, mid_y, center_x, mid_y + 30)        self.draw_resistor(center_x, mid_y + 30, "v", f"R2\n{r2_val:.1f}Ω")        self.draw_line(center_x, mid_y + 30 + 60, center_x, gnd_y)                self.draw_line(x_in, gnd_y, x_out, gnd_y)        self.draw_dot(center_x, mid_y); self.draw_dot(center_x, gnd_y)        c.create_text(x_in + (x_out-x_in)/2, gnd_y + 20, text="Общий (GND)", fill="gray", font=("Segoe UI", 9))