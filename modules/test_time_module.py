# -*- coding: utf-8 -*-import jsonimport osimport mathimport tkinter as tkfrom tkinter import messagebox, filedialog, simpledialogfrom datetime import datetime, timedeltaimport tkinter.ttk as ttkfrom core.utils import tbfrom core.base_module import CalcModule# --- OpenPYXL (–≠–∫—Å–ø–æ—Ä—Ç –≤ Excel) ---try:    import openpyxl    from openpyxl.styles import Font, Alignment, Border, Side, PatternFill    EXCEL_AVAILABLE = Trueexcept ImportError:    EXCEL_AVAILABLE = FalseCUSTOM_STEPS_FILE = "custom_steps.json"# --- –ë–ê–ó–ê –ó–ù–ê–ù–ò–ô (–°–í–û–ô–°–¢–í–ê –ò–°–ü–´–¢–ê–ù–ò–ô) ---# thermal: —Ç—Ä–µ–±—É–µ—Ç –¢_–Ω–∞—á, –¢_–∫–æ–Ω, –°–∫–æ—Ä–æ—Å—Ç—å -> –°—á–∏—Ç–∞–µ—Ç –≤—Ä–µ–º—è# mechanical: —Ç—Ä–µ–±—É–µ—Ç –ê–º–ø–ª–∏—Ç—É–¥—É, –ß–∞—Å—Ç–æ—Ç—É# climatic: —Ç—Ä–µ–±—É–µ—Ç –í–ª–∞–∂–Ω–æ—Å—Ç—å/–î–∞–≤–ª–µ–Ω–∏–µIMPACT_META = {    "–ù–ö–£ (–ù–æ—Ä–º–∞–ª—å–Ω—ã–µ —É—Å–ª–æ–≤–∏—è)": {"type": "simple", "unit": "", "color": "#2ecc71"},        # –¢–ï–†–ú–ò–ö–ê    "–ü–æ–≤—ã—à–µ–Ω–Ω–∞—è —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ —Å—Ä–µ–¥—ã": {"type": "thermal", "unit": "¬∞C", "color": "#e74c3c"},    "–ü–æ–Ω–∏–∂–µ–Ω–Ω–∞—è —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ —Å—Ä–µ–¥—ã": {"type": "thermal", "unit": "¬∞C", "color": "#3498db"},    "–ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã (–¶–∏–∫–ª–∏—Ä–æ–≤–∞–Ω–∏–µ)": {"type": "thermal", "unit": "¬∞C", "color": "#9b59b6"},    "–¢–µ—Ä–º–æ—É–¥–∞—Ä": {"type": "thermal", "unit": "¬∞C", "color": "#e67e22"},    "–¢–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–∞—è —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞ (–¢–µ—Ä–º–æ)": {"type": "thermal", "unit": "¬∞C", "color": "#d35400"},        # –ú–ï–•–ê–ù–ò–ö–ê    "–í–∏–±—Ä–∞—Ü–∏—è —Å–∏–Ω—É—Å–æ–∏–¥–∞–ª—å–Ω–∞—è": {"type": "mechanical", "p1": "–ê–º–ø–ª–∏—Ç—É–¥–∞", "p2": "–ß–∞—Å—Ç–æ—Ç–∞", "u1": "g", "u2": "–ì—Ü", "color": "#95a5a6"},    "–í–∏–±—Ä–∞—Ü–∏—è —à–∏—Ä–æ–∫–æ–ø–æ–ª–æ—Å–Ω–∞—è (–®–°–í)": {"type": "mechanical", "p1": "–°–ü–ú", "p2": "–î–∏–∞–ø–∞–∑–æ–Ω", "u1": "g¬≤/–ì—Ü", "u2": "–ì—Ü", "color": "#7f8c8d"},    "–ú–µ—Ö–∞–Ω–∏—á–µ—Å–∫–∏–π —É–¥–∞—Ä –æ–¥–∏–Ω–æ—á–Ω—ã–π": {"type": "mechanical", "p1": "–ü–∏–∫. —É–¥–∞—Ä", "p2": "–î–ª–∏—Ç.", "u1": "g", "u2": "–º—Å", "color": "#34495e"},    "–ú–µ—Ö–∞–Ω–∏—á–µ—Å–∫–∏–π —É–¥–∞—Ä –º–Ω–æ–≥–æ–∫—Ä–∞—Ç–Ω—ã–π": {"type": "mechanical", "p1": "–ü–∏–∫. —É–¥–∞—Ä", "p2": "–î–ª–∏—Ç.", "u1": "g", "u2": "–º—Å", "color": "#2c3e50"},    "–ê–∫—É—Å—Ç–∏—á–µ—Å–∫–∏–π —à—É–º": {"type": "mechanical", "p1": "–£—Ä–æ–≤–µ–Ω—å", "p2": "–ß–∞—Å—Ç–æ—Ç–∞", "u1": "–¥–ë", "u2": "–ì—Ü", "color": "#bdc3c7"},        # –ö–õ–ò–ú–ê–¢–ò–ö–ê    "–ü–æ–≤—ã—à–µ–Ω–Ω–∞—è –≤–ª–∞–∂–Ω–æ—Å—Ç—å": {"type": "climatic", "p1": "–í–ª–∞–∂–Ω–æ—Å—Ç—å", "u1": "%", "color": "#1abc9c"},    "–ü–æ–Ω–∏–∂–µ–Ω–Ω–æ–µ –¥–∞–≤–ª–µ–Ω–∏–µ (–í–∞–∫—É—É–º)": {"type": "climatic", "p1": "–î–∞–≤–ª–µ–Ω–∏–µ", "u1": "–º–º —Ä—Ç.—Å—Ç.", "color": "#8e44ad"},    "–ü–æ–≤—ã—à–µ–Ω–Ω–æ–µ –¥–∞–≤–ª–µ–Ω–∏–µ": {"type": "climatic", "p1": "–î–∞–≤–ª–µ–Ω–∏–µ", "u1": "–∞—Ç–º", "color": "#8e44ad"},    "–°–æ–ª—è–Ω–æ–π —Ç—É–º–∞–Ω": {"type": "simple", "unit": "", "color": "#ecf0f1"},    "–î–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è –ø—ã–ª—å (–ü–µ—Å–æ–∫)": {"type": "climatic", "p1": "–ö–æ–Ω—Ü–µ–Ω—Ç—Ä.", "u1": "–≥/–º¬≥", "color": "#f1c40f"},    "–î–æ–∂–¥—å / –û—Å–∞–¥–∫–∏": {"type": "climatic", "p1": "–ò–Ω—Ç–µ–Ω—Å–∏–≤–Ω.", "u1": "–º–º/–º–∏–Ω", "color": "#3498db"},    "–ò–Ω–µ–π –∏ —Ä–æ—Å–∞": {"type": "simple", "unit": "", "color": "#a29bfe"}}# --- –ì–ï–ù–ï–†–ê–¢–û–†–´ –°–ü–ò–°–ö–û–í –î–õ–Ø –í–´–ü–ê–î–ê–Æ–©–ò–• –ú–ï–ù–Æ ---def gen_time_opts():    opts = []    # –ú–µ–ª–∫–∏–π —à–∞–≥ (5 –º–∏–Ω) –¥–ª—è –∫–æ—Ä–æ—Ç–∫–∏—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤    for h in range(5):        for m in range(0, 60, 5):            if h==0 and m==0: continue            opts.append(f"{h}:{m:02}")    # –°—Ä–µ–¥–Ω–∏–π —à–∞–≥ (30 –º–∏–Ω)    for h in range(5, 25): opts.extend([f"{h}:00", f"{h}:30"])    # –î–ª–∏—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–æ—Ü–µ—Å—Å—ã    opts.extend(["48:00", "72:00", "96:00", "100:00"])    return optsdef gen_temp_opts(): return [str(x) for x in range(-70, 160, 5)] # –æ—Ç -70 –¥–æ 160 —Å —à–∞–≥–æ–º 5def gen_speed_opts():    return [""] + [f"{x} ¬∞C/–º–∏–Ω" for x in [0.5, 1, 2, 3, 5, 10, 15, 20]] + ["–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è"]TIME_PRESETS = gen_time_opts()TEMP_PRESETS = gen_temp_opts()SPEED_PRESETS = gen_speed_opts()# --- –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ---def parse_float_safe(val):    """–ü—Ä–µ–≤—Ä–∞—â–∞–µ—Ç '2 ¬∞C/–º–∏–Ω' –∏–ª–∏ '2,5' –≤ —á–∏—Å–ª–æ 2.0 –∏–ª–∏ 2.5"""    try:        if not val: return 0.0        # –ë–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—É—é —á–∞—Å—Ç—å –¥–æ –ø—Ä–æ–±–µ–ª–∞ (–¥–ª—è "2 ¬∞C/–º–∏–Ω")        clean = str(val).split()[0].replace(",", ".")        return float(clean)    except:        return 0.0def parse_time_str(val):    """–ü—Ä–µ–≤—Ä–∞—â–∞–µ—Ç '1:30' –∏–ª–∏ '1.5' –≤ 1.5 (—á–∞—Å–æ–≤)"""    val = str(val).replace(",", ".").strip()    if not val: return 0.0    if ":" in val:        try:            parts = val.split(":")            h, m = float(parts[0]), float(parts[1])            return h + m/60.0        except: return 0.0    else:        try: return float(val)        except: return 0.0def fmt_time(h_float):    """–ü—Ä–µ–≤—Ä–∞—â–∞–µ—Ç 1.5 –≤ '1:30' (–¥–ª—è —Ç–∞–±–ª–∏—Ü—ã)"""    if h_float < 0.001: return "0:00"    tm = int(round(h_float*60))    h, m = tm // 60, tm % 60    return f"{h}:{m:02}"# --- –ö–õ–ê–°–° –û–î–ù–û–ô –í–ö–õ–ê–î–ö–ò (–ü–°–ò/–ü–ò/–¢–¢) ---class TestScheduleTab:    def __init__(self, parent_notebook, tab_name, master_module):        self.name = tab_name        self.master = master_module        self.steps = []        self.notebook = parent_notebook        self.frame = tb.Frame(parent_notebook, padding=10)        parent_notebook.add(self.frame, text=tab_name)                self.impact_list = sorted(list(IMPACT_META.keys()))        self.load_customs()                # –ì–∞–ª–æ—á–∫–∞ "–ü–æ–¥—Ä–æ–±–Ω—ã–π —Ä–µ–∂–∏–º"        self.var_show_details = tk.BooleanVar(value=True)                 self.col_headers = {            "num": "‚Ññ", "name": "–†–µ–∂–∏–º", "p1": "–ü–∞—Ä–∞–º–µ—Ç—Ä 1 (–ù–∞—á)",             "p2": "–ü–∞—Ä–∞–º–µ—Ç—Ä 2 (–ö–æ–Ω)", "speed": "–°–∫–æ—Ä–æ—Å—Ç—å",            "time": "–í—Ä–µ–º—è", "cycles": "–¶–∏–∫–ª—ã", "nku": "–ù–ö–£", "total": "–ò—Ç–æ–≥–æ"        }        self._build_ui()    def _build_ui(self):        # 1. –ü–ê–ù–ï–õ–¨ –û–ü–¶–ò–ô        opts = tb.Frame(self.frame)        opts.pack(fill="x", pady=(0, 5))        tb.Checkbutton(opts, text="–ü–æ–¥—Ä–æ–±–Ω—ã–π —Ä–µ–∂–∏–º (–¢, g, –ì—Ü, —Å–∫–æ—Ä–æ—Å—Ç—å)",                        variable=self.var_show_details, bootstyle="round-toggle", command=self.toggle_cols).pack(side="left")        # 2. –¢–ê–ë–õ–ò–¶–ê        style = ttk.Style()        # –ú—ã –ù–ï –∏—Å–ø–æ–ª—å–∑—É–µ–º theme_use("clam"), —á—Ç–æ–±—ã –Ω–µ –ª–æ–º–∞—Ç—å —Ü–≤–µ—Ç–∞,         # –Ω–æ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º —à—Ä–∏—Ñ—Ç –∏ –≤—ã—Å–æ—Ç—É —Å—Ç—Ä–æ–∫        style.configure("Treeview", font=("Segoe UI", 10), rowheight=30)        style.configure("Treeview.Heading", font=("Segoe UI", 10, "bold"))        cols = ("num", "name", "p1", "p2", "speed", "time", "cycles", "nku", "total")        self.tree = tb.Treeview(self.frame, columns=cols, show="headings", selectmode="browse", height=10)                for c in cols:            self.tree.heading(c, text=self.col_headers[c], command=lambda _c=c: self.sort_col(_c, False))        # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —à–∏—Ä–∏–Ω—ã        widths = [40, 320, 90, 90, 90, 70, 50, 70, 80]        for c, w in zip(cols, widths):            self.tree.column(c, width=w, anchor="center" if c!="name" else "w")        sb = tb.Scrollbar(self.frame, orient="vertical", command=self.tree.yview)        self.tree.configure(yscrollcommand=sb.set)        self.tree.pack(side="top", fill="both", expand=True)        sb.pack(side="right", fill="y", in_=self.tree)                # –ë–∏–Ω–¥—ã (–∫–ª–∏–∫–∏)        self.tree.bind("<Double-1>", self.on_double_click)        self.tree.bind("<Button-3>", self.show_context_menu)                # –¢–µ–≥–∏ –¥–ª—è —Ä–∞—Å–∫—Ä–∞—Å–∫–∏ —Å—Ç—Ä–æ–∫ (–ó–µ–±—Ä–∞)        self.tree.tag_configure("odd", background="#f4f6f7") # –°–≤–µ—Ç–ª–æ-—Å–µ—Ä—ã–π        self.tree.tag_configure("even", background="#ffffff") # –ë–µ–ª—ã–π        self.tree.tag_configure("total_row", background="#bdc3c7", font=("Segoe UI", 10, "bold")) # –ò—Ç–æ–≥        # 3. –ö–ù–û–ü–ö–ò –£–ü–†–ê–í–õ–ï–ù–ò–Ø –¢–ê–ë–õ–ò–¶–ï–ô        ctrl = tb.Frame(self.frame, padding=(0, 5))        ctrl.pack(fill="x")        tb.Button(ctrl, text="‚ñ≤", bootstyle="secondary-outline", width=4, command=lambda: self.move_row(-1)).pack(side="left", padx=2)        tb.Button(ctrl, text="‚ñº", bootstyle="secondary-outline", width=4, command=lambda: self.move_row(1)).pack(side="left", padx=2)        tb.Button(ctrl, text="üóë –£–¥–∞–ª–∏—Ç—å", bootstyle="danger-outline", command=self.delete_step).pack(side="left", padx=10)        # 4. –ö–û–ù–°–¢–†–£–ö–¢–û–† –ò–°–ü–´–¢–ê–ù–ò–Ø (–ü–ê–ù–ï–õ–¨ –î–û–ë–ê–í–õ–ï–ù–ò–Ø)        add_box = tb.Labelframe(self.frame, text="–î–æ–±–∞–≤–∏—Ç—å / –†–∞—Å—Å—á–∏—Ç–∞—Ç—å —ç—Ç–∞–ø", padding=10, bootstyle="primary")        add_box.pack(fill="x")        # --- –†—è–¥ 1: –¢–∏–ø –≤–æ–∑–¥–µ–π—Å—Ç–≤–∏—è –∏ –ü–∞—Ä–∞–º–µ—Ç—Ä—ã ---        r1 = tb.Frame(add_box)        r1.pack(fill="x", pady=2)                # –ë–ª–æ–∫ –≤—ã–±–æ—Ä–∞ —Ç–∏–ø–∞        f_type = tb.Frame(r1)        f_type.pack(side="left", fill="y")        tb.Label(f_type, text="–í–∏–¥ –≤–æ–∑–¥–µ–π—Å—Ç–≤–∏—è:", font=("", 9, "bold")).pack(anchor="w")                self.var_imp_name = tk.StringVar()        self.cb_imp = tb.Combobox(f_type, textvariable=self.var_imp_name, values=self.impact_list, height=15, width=35)        self.cb_imp.pack(pady=2)        self.cb_imp.bind("<<ComboboxSelected>>", self.on_type_changed)        # –ë–ª–æ–∫ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ (–¢, g, –∏ —Ç.–¥.)        f_params = tb.Frame(r1)        f_params.pack(side="left", padx=20, fill="both", expand=True)                self.var_p1 = tk.StringVar(value="25")         self.var_p2 = tk.StringVar(value="")           self.var_spd = tk.StringVar(value="")                  # –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–ò–ô –ü–ï–†–ï–°–ß–ï–¢ –ü–†–ò –ò–ó–ú–ï–ù–ï–ù–ò–ò –≠–¢–ò–• –ü–ï–†–ï–ú–ï–ù–ù–´–•        self.var_p1.trace("w", self.recalc_time_auto)        self.var_p2.trace("w", self.recalc_time_auto)        self.var_spd.trace("w", self.recalc_time_auto)        # –í–∏–¥–∂–µ—Ç—ã (–ü–æ–¥–ø–∏—Å–∏ –∏ –ø–æ–ª—è)        self.lbl_p1 = tb.Label(f_params, text="–¢ –Ω–∞—á:")        self.ent_p1 = tb.Combobox(f_params, textvariable=self.var_p1, values=TEMP_PRESETS, width=8)                self.lbl_p2 = tb.Label(f_params, text="–¢ –∫–æ–Ω:")        self.ent_p2 = tb.Combobox(f_params, textvariable=self.var_p2, values=TEMP_PRESETS, width=8)                self.lbl_spd = tb.Label(f_params, text="–°–∫–æ—Ä–æ—Å—Ç—å:")        self.ent_spd = tb.Combobox(f_params, textvariable=self.var_spd, values=SPEED_PRESETS, width=12)        # –†–∞–∑–º–µ—â–∞–µ–º        self.lbl_p1.pack(side="left", padx=2)        self.ent_p1.pack(side="left", padx=2)        self.lbl_p2.pack(side="left", padx=5)        self.ent_p2.pack(side="left", padx=2)        self.lbl_spd.pack(side="left", padx=5)        self.ent_spd.pack(side="left", padx=2)        # --- –†—è–¥ 2: –í—Ä–µ–º—è, –¶–∏–∫–ª—ã, –ö–Ω–æ–ø–∫–∞ ---        r2 = tb.Frame(add_box)        r2.pack(fill="x", pady=10)                self.var_time = tk.StringVar(value="1:00")        self.var_cycl = tk.StringVar(value="1")        self.var_nku = tk.StringVar(value="0:00")        # –í—Ä–µ–º—è        f_time = tb.Frame(r2)        f_time.pack(side="left")        tb.Label(f_time, text="–í—Ä–µ–º—è:", font=("", 9, "bold")).pack(side="left")        self.ent_time = tb.Combobox(f_time, textvariable=self.var_time, values=TIME_PRESETS, width=10, font=("Consolas", 10, "bold"))        self.ent_time.pack(side="left", padx=5)                # –¶–∏–∫–ª—ã        tb.Label(r2, text="–¶–∏–∫–ª—ã:").pack(side="left", padx=(15, 2))        tb.Spinbox(r2, textvariable=self.var_cycl, from_=1, to=999, width=5).pack(side="left")                # –ù–ö–£        tb.Label(r2, text="–ù–ö–£:").pack(side="left", padx=(15, 2))        tb.Combobox(r2, textvariable=self.var_nku, values=TIME_PRESETS, width=8).pack(side="left")        # –ö–Ω–æ–ø–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è        tb.Button(r2, text="–î–û–ë–ê–í–ò–¢–¨ –í –¢–ê–ë–õ–ò–¶–£ ‚Üµ", bootstyle="success", command=self.add_step_action).pack(side="right", padx=10)        # –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–µ –º–µ–Ω—é        self.menu = tk.Menu(self.tree, tearoff=0)        self.menu.add_command(label="2Ô∏è‚É£ –î—É–±–ª–∏—Ä–æ–≤–∞—Ç—å", command=self.duplicate_row)        self.menu.add_command(label="üóë –£–¥–∞–ª–∏—Ç—å", command=self.delete_step)        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤–∏–¥–∏–º–æ—Å—Ç–∏        self.on_type_changed(None)        self.toggle_cols()    def show_context_menu(self, event):        item = self.tree.identify_row(event.y)        if item and item != "total":            self.tree.selection_set(item)            self.menu.post(event.x_root, event.y_root)    def on_type_changed(self, event):        """–ú–µ–Ω—è–µ—Ç –ø–æ–ª—è –≤–≤–æ–¥–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞ –∏—Å–ø—ã—Ç–∞–Ω–∏—è"""        name = self.var_imp_name.get()        meta = IMPACT_META.get(name, {"type": "simple"})        t = meta.get("type", "simple")        # –°–∫—Ä—ã–≤–∞–µ–º –≤—Å–µ –ø–æ–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤        self.lbl_p1.pack_forget(); self.ent_p1.pack_forget()        self.lbl_p2.pack_forget(); self.ent_p2.pack_forget()        self.lbl_spd.pack_forget(); self.ent_spd.pack_forget()                self.ent_time.config(state="normal") # –†–∞–∑–±–ª–æ–∫–∏—Ä—É–µ–º –≤—Ä–µ–º—è        if t == "thermal":            # –¢–ï–†–ú–ò–ö–ê: –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –¢–Ω–∞—á, –¢–∫–æ–Ω, –°–∫–æ—Ä–æ—Å—Ç—å            self.lbl_p1.config(text="–¢ –Ω–∞—á (¬∞C):"); self.ent_p1.config(values=TEMP_PRESETS)            self.lbl_p2.config(text="–¢ –∫–æ–Ω (¬∞C):"); self.ent_p2.config(values=TEMP_PRESETS)                        self.lbl_p1.pack(side="left", padx=2); self.ent_p1.pack(side="left", padx=2)            self.lbl_p2.pack(side="left", padx=5); self.ent_p2.pack(side="left", padx=2)            self.lbl_spd.pack(side="left", padx=5); self.ent_spd.pack(side="left", padx=2)                        # –°–±—Ä–∞—Å—ã–≤–∞–µ–º –≤—Ä–µ–º—è –≤ 0, —Ç–∞–∫ –∫–∞–∫ –æ–Ω–æ –±—É–¥–µ—Ç —Ä–∞—Å—Å—á–∏—Ç–∞–Ω–æ            self.var_time.set("0:00")                    elif t == "mechanical":            # –ú–ï–•–ê–ù–ò–ö–ê: –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–∑ –±–∞–∑—ã (–ê–º–ø–ª–∏—Ç—É–¥–∞, –ß–∞—Å—Ç–æ—Ç–∞)            u1, u2 = meta.get("u1", ""), meta.get("u2", "")            l1, l2 = meta.get("p1", "–ü1"), meta.get("p2", "–ü2")                        self.lbl_p1.config(text=f"{l1} ({u1}):"); self.ent_p1.config(values=[])            self.lbl_p1.pack(side="left", padx=2); self.ent_p1.pack(side="left", padx=2)            if l2:                self.lbl_p2.config(text=f"{l2} ({u2}):"); self.ent_p2.config(values=[])                self.lbl_p2.pack(side="left", padx=5); self.ent_p2.pack(side="left", padx=2)            self.var_time.set("1:00")        elif t == "climatic":            # –ö–õ–ò–ú–ê–¢–ò–ö–ê: –û–¥–∏–Ω –ø–∞—Ä–∞–º–µ—Ç—Ä            u1, l1 = meta.get("u1", ""), meta.get("p1", "–ó–Ω–∞—á.")            self.lbl_p1.config(text=f"{l1} ({u1}):"); self.ent_p1.config(values=[])            self.lbl_p1.pack(side="left", padx=2); self.ent_p1.pack(side="left", padx=2)            self.var_time.set("1:00")                else:            self.var_time.set("1:00")    def recalc_time_auto(self, *args):        """–£–º–Ω—ã–π —Ä–∞—Å—á–µ—Ç –≤—Ä–µ–º–µ–Ω–∏ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –ø–æ–ª–µ–π"""        name = self.var_imp_name.get()        # –°—á–∏—Ç–∞–µ–º –¢–û–õ–¨–ö–û –µ—Å–ª–∏ —ç—Ç–æ —Ç–µ—Ä–º–∏–∫–∞        if IMPACT_META.get(name, {}).get("type") != "thermal": return                try:            t1 = parse_float_safe(self.var_p1.get())            t2 = parse_float_safe(self.var_p2.get())            spd = parse_float_safe(self.var_spd.get())                        if spd <= 0: return # –ó–∞—â–∏—Ç–∞ –æ—Ç –¥–µ–ª–µ–Ω–∏—è –Ω–∞ –Ω–æ–ª—å                        # –§–æ—Ä–º—É–ª–∞: –í—Ä–µ–º—è (–º–∏–Ω) = –†–∞–∑–Ω–∏—Ü–∞ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä / –°–∫–æ—Ä–æ—Å—Ç—å            delta = abs(t2 - t1)            minutes = delta / spd                        # –ü–µ—Ä–µ–≤–æ–¥ –≤ —á–∞—Å—ã            h_val = minutes / 60.0                        # –°—Ç–∞–≤–∏–º –≤ –ø–æ–ª–µ –≤—Ä–µ–º–µ–Ω–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä "0:25")            self.var_time.set(fmt_time(h_val))                    except Exception:            pass    def toggle_cols(self):        """–°–∫—Ä—ã—Ç–∏–µ/–ø–æ–∫–∞–∑ —Å—Ç–æ–ª–±—Ü–æ–≤ –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–µ–π"""        if self.var_show_details.get():            self.tree.column("p1", width=100, stretch=True)            self.tree.column("p2", width=100, stretch=True)            self.tree.column("speed", width=100, stretch=True)        else:            self.tree.column("p1", width=0, stretch=False)            self.tree.column("p2", width=0, stretch=False)            self.tree.column("speed", width=0, stretch=False)    def add_step_action(self):        try: time_val = parse_time_str(self.var_time.get())        except: messagebox.showerror("–û—à–∏–±–∫–∞", "–í—Ä–µ–º—è"); return        try: cycles = max(1, int(float(self.var_cycl.get().replace(",", "."))))        except: messagebox.showerror("–û—à–∏–±–∫–∞", "–¶–∏–∫–ª—ã"); return        try: nku_val = parse_time_str(self.var_nku.get())        except: messagebox.showerror("–û—à–∏–±–∫–∞", "–ù–ö–£"); return        name_raw = self.var_imp_name.get()        p1, p2, spd = self.var_p1.get(), self.var_p2.get(), self.var_spd.get()                # –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –∫—Ä–∞—Å–∏–≤–æ–≥–æ –Ω–∞–∑–≤–∞–Ω–∏—è        meta = IMPACT_META.get(name_raw, {})        mtype = meta.get("type", "simple")        display_name = name_raw                if mtype == "thermal" and p1 and p2:             display_name = f"{name_raw} ({p1} ‚Üí {p2} ¬∞C)"        elif mtype == "mechanical":            u1, u2 = meta.get("u1",""), meta.get("u2","")            if p1 and p2: display_name = f"{name_raw} ({p1}{u1}, {p2}{u2})"            elif p1: display_name = f"{name_raw} ({p1}{u1})"        elif mtype == "climatic" and p1:             display_name = f"{name_raw} ({p1}{meta.get('u1','')})"        max_n = 0        for s in self.steps:             if s['num'] > max_n: max_n = s['num']        step = {            "num": max_n + 1, "name": display_name, "raw_name": name_raw,            "p1": p1, "p2": p2, "speed": spd,            "time": time_val, "cycles": cycles, "nku": nku_val,            "total": (time_val + nku_val) * cycles        }        self.steps.append(step)        self.refresh_table()        self.master.recalculate_totals()    def duplicate_row(self):        sel = self.tree.selection()        if not sel or sel[0] == "total": return        uid = sel[0]        src = None        for s in self.steps:            if str(id(s)) == uid: src = s; break        if src:            new_s = src.copy()            new_s["num"] = self.steps[-1]["num"] + 1 if self.steps else 1            self.steps.append(new_s)            self.refresh_table()            self.master.recalculate_totals()    def delete_step(self):        sel = self.tree.selection()        if not sel or sel[0] == "total": return        uid = sel[0]        for i, s in enumerate(self.steps):            if str(id(s)) == uid: del self.steps[i]; break        self.refresh_table()        self.master.recalculate_totals()    def move_row(self, d):        sel = self.tree.selection()        if not sel or sel[0] == "total": return        uid = sel[0]        idx = -1        for i, s in enumerate(self.steps):            if str(id(s)) == uid: idx = i; break        if idx != -1:            n = idx + d            if 0 <= n < len(self.steps):                self.steps[idx], self.steps[n] = self.steps[n], self.steps[idx]                self.refresh_table()                self.tree.selection_set(str(id(self.steps[n])))    def sort_col(self, col, rev):        self.steps.sort(key=lambda x: str(x.get(col, "")), reverse=rev)        self.tree.heading(col, command=lambda: self.sort_col(col, not rev))        self.refresh_table()    def refresh_table(self):        for i in self.tree.get_children(): self.tree.delete(i)                tt, tn, tg = 0, 0, 0        for idx, s in enumerate(self.steps):            tt += s['time']*s['cycles']            tn += s['nku']*s['cycles']            s['total'] = (s['time'] + s['nku']) * s['cycles']            tg += s['total']                        tag = "even" if idx % 2 == 0 else "odd"            vals = (s['num'], s['name'], s.get('p1',''), s.get('p2',''), s.get('speed',''),                    fmt_time(s['time']), s['cycles'], fmt_time(s['nku']), fmt_time(s['total']))            self.tree.insert("", "end", iid=str(id(s)), values=vals, tags=(tag,))                    self.tree.insert("", "end", iid="total", values=("‚àë", "–ò–¢–û–ì–û:", "", "", "",             fmt_time(tt), "", fmt_time(tn), fmt_time(tg)), tags=("total_row",))    def on_double_click(self, event):        # –î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ - —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ —è—á–µ–π–∫–µ        region = self.tree.identify("region", event.x, event.y)        if region != "cell": return        col = self.tree.identify_column(event.x)        uid = self.tree.identify_row(event.y)        if uid == "total" or not uid: return        step = None        for s in self.steps:            if str(id(s)) == uid: step = s; break        if not step: return        col_idx = int(col.replace('#', '')) - 1        key = ["num", "name", "p1", "p2", "speed", "time", "cycles", "nku", "total"][col_idx]        if key in ["total", "num"]: return         x, y, w, h = self.tree.bbox(uid, col)        widget = None        curr_val = str(step.get(key, ""))                # –í—ã–±–∏—Ä–∞–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –≤–∏–¥–∂–µ—Ç        if key == "name": widget = tb.Combobox(self.tree, values=self.impact_list)        elif key == "speed": widget = tb.Combobox(self.tree, values=SPEED_PRESETS)        elif key in ["time", "nku"]: widget = tb.Combobox(self.tree, values=TIME_PRESETS)        elif key in ["p1", "p2"]: widget = tb.Combobox(self.tree, values=TEMP_PRESETS)        elif key == "cycles": widget = tb.Spinbox(self.tree, from_=1, to=999)        else: widget = tb.Entry(self.tree)        widget.place(x=x, y=y, width=w, height=h)        widget.insert(0, curr_val)        widget.focus()        def save(e):            val = widget.get()            try:                if key == "cycles": step["cycles"] = max(1, int(float(val.replace(",", "."))))                elif key in ["time", "nku"]: step[key] = parse_time_str(val)                else: step[key] = val                                # –ï—Å–ª–∏ –∏–∑–º–µ–Ω–∏–ª–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ç–µ—Ä–º–∏–∫–∏ - –ø–µ—Ä–µ—Å—á–∏—Ç–∞–µ–º –≤—Ä–µ–º—è                if key in ["speed", "p1", "p2"] and IMPACT_META.get(step.get("raw_name"), {}).get("type") == "thermal":                    t1 = parse_float_safe(step.get("p1"))                    t2 = parse_float_safe(step.get("p2"))                    spd = parse_float_safe(step.get("speed"))                    if spd > 0:                        step["time"] = abs(t2 - t1) / spd / 60.0                                step["total"] = (step["time"] + step["nku"]) * step["cycles"]                widget.destroy()                self.refresh_table()                self.master.recalculate_totals()            except: pass                widget.bind("<Return>", save)        widget.bind("<FocusOut>", lambda e: widget.destroy())    def load_customs(self):        if os.path.exists(CUSTOM_STEPS_FILE):            try:                with open(CUSTOM_STEPS_FILE, "r", encoding="utf-8") as f:                    for x in json.load(f):                        if x not in self.impact_list: self.impact_list.append(x)            except: pass        def get_data(self): return self.steps    def set_data(self, d):         self.steps = d        self.refresh_table()    def get_total_hours(self): return sum(s['total'] for s in self.steps)# --- –û–°–ù–û–í–ù–û–ô –ö–õ–ê–°–° –ú–û–î–£–õ–Ø ---class TestTimeModule(CalcModule):    key = "test_time"    title = "–ì—Ä–∞—Ñ–∏–∫ –∏—Å–ø—ã—Ç–∞–Ω–∏–π (Engineer Pro)"    def __init__(self, app):        super().__init__(app)        self.var_product = tk.StringVar()        self.var_decimal = tk.StringVar(value="–ò–£–Ø–î.")        self.var_start = tk.StringVar(value=datetime.now().strftime("%d.%m.%Y %H:%M"))        self.var_end = tk.StringVar(value="‚Äî")        self.var_total_h = tk.StringVar(value="0—á 00–º")        self.tabs = {}    def build_ui(self, parent: tb.Frame) -> tb.Frame:        self.frame = tb.Frame(parent)                # –®–ê–ü–ö–ê        top = tb.Frame(self.frame, padding=5)        top.pack(fill="x")        fr_info = tb.Labelframe(top, text="–ò–∑–¥–µ–ª–∏–µ", padding=5)        fr_info.pack(side="left", fill="both", expand=True)        tb.Label(fr_info, text="–ù–∞–∑–≤–∞–Ω–∏–µ:").grid(row=0, column=0); tb.Entry(fr_info, textvariable=self.var_product, width=30).grid(row=0, column=1)        tb.Label(fr_info, text="–î–µ—Ü–∏–±–µ–ª—å–Ω—ã–π:").grid(row=1, column=0); tb.Entry(fr_info, textvariable=self.var_decimal, width=20).grid(row=1, column=1)        dash = tb.Frame(top, padding=5)        dash.pack(side="right", fill="both")                # –¶–í–ï–¢–ê –ö–ê–†–¢–û–ß–ï–ö: –°–µ—Ä—ã–π (–ù–∞—á–∞–ª–æ), –°–∏–Ω–∏–π (–î–ª–∏—Ç.), –¢–µ–º–Ω—ã–π (–ö–æ–Ω–µ—Ü)        for txt, var, color in [("–ù–ê–ß–ê–õ–û", self.var_start, "secondary"), ("–î–õ–ò–¢–ï–õ–¨–ù–û–°–¢–¨", self.var_total_h, "info"), ("–ö–û–ù–ï–¶", self.var_end, "dark")]:            c = tb.Frame(dash, bootstyle=color)            c.pack(side="left", padx=2, fill="y")            f = tb.Frame(c, padding=5, bootstyle=color)            f.pack(fill="both")            tb.Label(f, text=txt, bootstyle=f"inverse-{color}", font=("",8)).pack(anchor="w")            if txt=="–ù–ê–ß–ê–õ–û":                 e = tb.Entry(f, textvariable=var, width=16, font=("Consolas",11))                e.pack(); e.bind("<FocusOut>", lambda e: self.recalculate_totals())            else: tb.Label(f, textvariable=var, bootstyle=f"inverse-{color}", font=("Consolas",12,"bold")).pack()        # –í–ö–õ–ê–î–ö–ò        self.notebook = ttk.Notebook(self.frame)        self.notebook.pack(fill="both", expand=True, padx=5, pady=5)        self.add_tab("–ü–°–ò"); self.add_tab("–ü–ò"); self.add_tab("–¢–¢")        self.plus_frame = tb.Frame(self.notebook)        self.notebook.add(self.plus_frame, text=" [ + ] ")        self.notebook.bind("<<NotebookTabChanged>>", self.on_tab_change)        # –§–£–¢–ï–†        bot = tb.Frame(self.frame, padding=5)        bot.pack(fill="x")        tb.Button(bot, text="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å", command=self.save_project, bootstyle="primary").pack(side="right")        tb.Button(bot, text="–ó–∞–≥—Ä—É–∑–∏—Ç—å", command=self.load_project, bootstyle="secondary").pack(side="right", padx=10)        if EXCEL_AVAILABLE: tb.Button(bot, text="Excel", command=self.export_excel, bootstyle="success").pack(side="right", padx=10)        return self.frame    def add_tab(self, name):        if name in self.tabs: return        self.tabs[name] = TestScheduleTab(self.notebook, name, self)        try: self.notebook.forget(self.plus_frame); self.notebook.add(self.plus_frame, text=" [ + ] ")        except: pass    def on_tab_change(self, event):        sel = self.notebook.select()        if not sel: return        if " [ + ] " in self.notebook.tab(self.notebook.index(sel), "text"):            nm = simpledialog.askstring("–ù–æ–≤–∞—è –≤–∫–ª–∞–¥–∫–∞", "–ù–∞–∑–≤–∞–Ω–∏–µ:")            if nm: self.add_tab(nm); self.notebook.select(self.notebook.index("end")-2)            else: self.notebook.select(0)    def recalculate_totals(self):        g = sum(t.get_total_hours() for t in self.tabs.values())        self.var_total_h.set(fmt_time(g))        try:             s = datetime.strptime(self.var_start.get(), "%d.%m.%Y %H:%M")            self.var_end.set((s + timedelta(hours=g)).strftime("%d.%m.%Y %H:%M"))        except: pass    def save_project(self):        d = {"ver": 4, "product": self.var_product.get(), "decimal": self.var_decimal.get(), "start": self.var_start.get(), "tabs": {k: v.get_data() for k,v in self.tabs.items()}}        p = filedialog.asksaveasfilename(defaultextension=".json");         if p:             with open(p, "w", encoding="utf-8") as f: json.dump(d, f, indent=2, ensure_ascii=False)            messagebox.showinfo("OK", "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ")    def load_project(self):        p = filedialog.askopenfilename()        if not p: return        try:            with open(p, "r", encoding="utf-8") as f: d = json.load(f)            self.var_product.set(d.get("product","")); self.var_decimal.set(d.get("decimal","")); self.var_start.set(d.get("start",""))            for k,v in d.get("tabs",{}).items():                if k not in self.tabs: self.add_tab(k)                self.tabs[k].set_data(v)            self.recalculate_totals()        except Exception as e: messagebox.showerror("Err", str(e))    def export_excel(self):        if not EXCEL_AVAILABLE: return messagebox.showerror("Err", "No openpyxl")        p = filedialog.asksaveasfilename(defaultextension=".xlsx")        if not p: return        try:            wb = openpyxl.Workbook();             if "Sheet" in wb.sheetnames: del wb["Sheet"]                        # STYLES            font_head = Font(bold=True)            border = Border(left=Side('thin'), right=Side('thin'), top=Side('thin'), bottom=Side('thin'))            fill_head = PatternFill("solid", fgColor="DDDDDD")                        for tname, tobj in self.tabs.items():                ws = wb.create_sheet(tname[:30])                                # INFO                ws["A1"] = "–ò–∑–¥–µ–ª–∏–µ:"; ws["B1"] = self.var_product.get()                ws["A2"] = "–î–µ—Ü–∏–±–µ–ª—å–Ω—ã–π:"; ws["B2"] = self.var_decimal.get()                ws["A3"] = "–ù–∞—á–∞–ª–æ:"; ws["B3"] = self.var_start.get()                ws.append([])                                # HEADER                headers = ["‚Ññ", "–ò—Å–ø—ã—Ç–∞–Ω–∏–µ", "–ü–∞—Ä–∞–º–µ—Ç—Ä 1", "–ü–∞—Ä–∞–º–µ—Ç—Ä 2", "–°–∫–æ—Ä–æ—Å—Ç—å", "–í—Ä–µ–º—è", "–¶–∏–∫–ª—ã", "–ù–ö–£", "–ò—Ç–æ–≥–æ"]                ws.append(headers)                                # Apply styles to header (Row 5)                for cell in ws[5]:                    cell.font = font_head                    cell.border = border                    cell.fill = fill_head                                gt = 0                for s in tobj.steps:                    row = [                        s['num'], s['name'], s.get('p1',''), s.get('p2',''), s.get('speed',''),                         fmt_time(s['time']), s['cycles'], fmt_time(s['nku']), fmt_time(s['total'])                    ]                    gt += s['total']                    ws.append(row)                    # Apply border to data row                    for cell in ws[ws.max_row]:                        cell.border = border                                # TOTAL ROW                ws.append(["", "–ò–¢–û–ì–û", "", "", "", "", "", "", fmt_time(gt)])                for cell in ws[ws.max_row]:                    cell.font = font_head                    cell.border = border                                ws.column_dimensions["B"].width = 50                ws.column_dimensions["C"].width = 15                ws.column_dimensions["D"].width = 15                            wb.save(p); messagebox.showinfo("OK", "Excel saved")        except Exception as e: messagebox.showerror("Err", str(e))