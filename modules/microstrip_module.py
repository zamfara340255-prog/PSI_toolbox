# -*- coding: utf-8 -*-import tkinter as tkimport mathfrom core.utils import tb, Cfrom core.base_module import CalcModuleclass MicrostripModule(CalcModule):    key = "microstrip"    title = "Микрополосковая линия"    def __init__(self, app):        super().__init__(app)                # Параметры подложки        self.var_er = tk.StringVar(value="4.4")   # FR-4        self.var_tand = tk.StringVar(value="0.02")         self.var_h = tk.StringVar(value="1.6")            self.var_t = tk.StringVar(value="0.035")          self.var_f = tk.StringVar(value="2.45")                   # Режим        self.var_mode = tk.IntVar(value=0)                # Целевые        self.var_target_z0 = tk.StringVar(value="50.0")        self.var_target_w = tk.StringVar(value="3.0")                # Результаты        self.var_res_main = tk.StringVar(value="-")        self.var_res_eff = tk.StringVar(value="-")         self.var_res_lambda = tk.StringVar(value="-")         self.var_res_loss = tk.StringVar(value="-")        # НОВОЕ: Задержка сигнала        self.var_res_delay = tk.StringVar(value="-")                # Калькулятор фазы        self.var_calc_len = tk.StringVar(value="10")        self.var_calc_deg = tk.StringVar(value="-")                self.canvas = None    def toolbar_actions(self):        return []    def build_ui(self, parent):        self.frame = tb.Frame(parent)        pad = 20                paned = tb.Frame(self.frame)        paned.pack(fill="both", expand=True, padx=pad, pady=pad)                # --- ЛЕВАЯ ПАНЕЛЬ ---        left = tb.Labelframe(paned, text="Параметры подложки (PCB)", padding=20)        left.pack(side="left", fill="y", padx=(0, 20))                tb.Label(left, text="Материал:", font=("Segoe UI", 9, "bold")).pack(anchor="w", pady=(0, 5))        btn_fr = tb.Frame(left)        btn_fr.pack(fill="x", pady=(0, 15))        tb.Button(btn_fr, text="FR-4", command=lambda: self.set_mat(4.4, 0.02), bootstyle="outline", width=6).pack(side="left", padx=(0,5))        tb.Button(btn_fr, text="RO4003", command=lambda: self.set_mat(3.55, 0.0027), bootstyle="outline", width=8).pack(side="left")        tb.Label(left, text="Диэлектрическая проницаемость (εr):", font=("Segoe UI", 9)).pack(anchor="w")        tb.Entry(left, textvariable=self.var_er).pack(fill="x", pady=(0, 10))                tb.Label(left, text="Тангенс угла потерь (tan δ):", font=("Segoe UI", 9)).pack(anchor="w")        tb.Entry(left, textvariable=self.var_tand).pack(fill="x", pady=(0, 10))        tb.Label(left, text="Толщина диэлектрика (H), мм:", font=("Segoe UI", 9)).pack(anchor="w")        tb.Entry(left, textvariable=self.var_h).pack(fill="x", pady=(0, 10))        tb.Label(left, text="Толщина меди (T), мм:", font=("Segoe UI", 9)).pack(anchor="w")        tb.Entry(left, textvariable=self.var_t).pack(fill="x", pady=(0, 5))                btn_cu = tb.Frame(left)        btn_cu.pack(fill="x", pady=(0, 15))        tb.Button(btn_cu, text="18 мкм", command=lambda: self.var_t.set("0.018"), bootstyle="outline", width=8).pack(side="left", padx=(0,5))        tb.Button(btn_cu, text="35 мкм", command=lambda: self.var_t.set("0.035"), bootstyle="outline").pack(side="left")        tb.Separator(left).pack(fill="x", pady=10)        tb.Label(left, text="Рабочая частота (F), ГГц:", font=("Segoe UI", 9, "bold")).pack(anchor="w")        tb.Entry(left, textvariable=self.var_f, bootstyle="info").pack(fill="x", pady=(0, 5))        # --- ПРАВАЯ ПАНЕЛЬ ---        right = tb.Frame(paned)        right.pack(side="right", fill="both", expand=True)                # Блок расчета        calc_box = tb.Labelframe(right, text="Параметры линии", padding=15)        calc_box.pack(fill="x", pady=(0, 15))                tb.Label(calc_box, text="Цель расчета:", font=("Segoe UI", 9, "bold")).pack(anchor="w")        r_frame = tb.Frame(calc_box)        r_frame.pack(fill="x", pady=(5, 10))        tb.Radiobutton(r_frame, text="Ширину (по Z0)", variable=self.var_mode, value=0, command=self.toggle_mode).pack(side="left", padx=(0, 20))        tb.Radiobutton(r_frame, text="Импеданс (по W)", variable=self.var_mode, value=1, command=self.toggle_mode).pack(side="left")        self.lbl_input = tb.Label(calc_box, text="Целевой импеданс (Z0), Ом:", font=("Segoe UI", 9))        self.lbl_input.pack(anchor="w")        self.ent_input = tb.Entry(calc_box, textvariable=self.var_target_z0, font=("Consolas", 11))        self.ent_input.pack(fill="x", pady=(0, 10))                tb.Button(calc_box, text="РАССЧИТАТЬ", command=self.calculate, bootstyle="primary").pack(fill="x")        # Результаты        res_box = tb.Frame(right, padding=15, bootstyle="secondary")        res_box.pack(fill="x", pady=(0, 15))                row1 = tb.Frame(res_box, bootstyle="secondary")        row1.pack(fill="x", pady=(0, 10))        self.lbl_res_title = tb.Label(row1, text="Ширина (W):", font=("Segoe UI", 12), bootstyle="inverse-secondary")        self.lbl_res_title.pack(side="left")        tb.Label(row1, textvariable=self.var_res_main, font=("Consolas", 20, "bold"), bootstyle="inverse-secondary").pack(side="right")                grid_res = tb.Frame(res_box, bootstyle="secondary")        grid_res.pack(fill="x")                def add_stat(parent, label, var, col):            f = tb.Frame(parent, bootstyle="secondary")            f.grid(row=0, column=col, sticky="w", padx=10)            tb.Label(f, text=label, font=("Segoe UI", 8), bootstyle="inverse-secondary", foreground="#cccccc").pack(anchor="w")            tb.Label(f, textvariable=var, font=("Segoe UI", 10, "bold"), bootstyle="inverse-secondary").pack(anchor="w")        add_stat(grid_res, "Задержка (Delay)", self.var_res_delay, 0)        add_stat(grid_res, "Эфф. ε_eff", self.var_res_eff, 1)        add_stat(grid_res, "Затухание (α)", self.var_res_loss, 2)        add_stat(grid_res, "Длина волны λg", self.var_res_lambda, 3)        # Калькулятор фазы        phase_box = tb.Labelframe(right, text="Электрическая длина (Фаза)", padding=10)        phase_box.pack(fill="x", pady=(0, 15))                pb_grid = tb.Frame(phase_box)        pb_grid.pack(fill="x")                tb.Label(pb_grid, text="Длина (мм):", font=("Segoe UI", 9)).pack(side="left")        tb.Entry(pb_grid, textvariable=self.var_calc_len, width=8).pack(side="left", padx=5)                tb.Button(pb_grid, text="⇄", command=self.calc_phase_len, bootstyle="info-outline", width=3).pack(side="left", padx=10)                tb.Label(pb_grid, text="Фаза (°):", font=("Segoe UI", 9)).pack(side="left")        tb.Entry(pb_grid, textvariable=self.var_calc_deg, width=8).pack(side="left", padx=5)        # Графика        self.canvas = tk.Canvas(right, bg="white", height=220, bd=0, highlightthickness=0)        self.canvas.pack(fill="both", expand=True)        self.toggle_mode()        self.calculate()        return self.frame    def set_mat(self, er, tand):        self.var_er.set(str(er))        self.var_tand.set(str(tand))    def toggle_mode(self):        mode = self.var_mode.get()        if mode == 0:            self.lbl_input.config(text="Целевой импеданс (Z0), Ом:")            self.ent_input.configure(textvariable=self.var_target_z0)            self.lbl_res_title.config(text="Ширина (W):")        else:            self.lbl_input.config(text="Ширина дорожки (W), мм:")            self.ent_input.configure(textvariable=self.var_target_w)            self.lbl_res_title.config(text="Импеданс (Z0):")    def _get(self, var):        try: return float(var.get().replace(",", "."))        except: return None    def calc_phase_len(self):        try:            L_phys = self._get(self.var_calc_len)            freq = self._get(self.var_f)            if self.var_res_eff.get() == "-": self.calculate()            eff = float(self.var_res_eff.get())                        if L_phys is not None:                # L -> Deg                lambda_g = 299.792 / (freq * math.sqrt(eff))                deg = (L_phys / lambda_g) * 360.0                self.var_calc_deg.set(f"{deg:.1f}")            else:                # Deg -> L                deg = self._get(self.var_calc_deg)                if deg is not None:                    lambda_g = 299.792 / (freq * math.sqrt(eff))                    L_phys = (deg / 360.0) * lambda_g                    self.var_calc_len.set(f"{L_phys:.2f}")        except: pass    def calculate(self):        try:            er = self._get(self.var_er)            h = self._get(self.var_h)            t = self._get(self.var_t)            freq_ghz = self._get(self.var_f)            tand = self._get(self.var_tand) or 0.0                        mode = self.var_mode.get()                        if not er or not h or not t: return            if er <= 0 or h <= 0: return            eff_val = 0.0                        def calc_microstrip(w_val):                if w_val <= 0: return 0, 0                u = w_val / h                eff = ((er + 1) / 2) + ((er - 1) / 2) * (1 / math.sqrt(1 + 12/u))                if u <= 1:                    z = (60 / math.sqrt(eff)) * math.log(8/u + 0.25*u)                else:                    z = (120 * math.pi) / (math.sqrt(eff) * (u + 1.393 + 0.667 * math.log(u + 1.444)))                return z, eff            best_w = 0.0                        if mode == 1: # Ищем Z0                w = self._get(self.var_target_w)                if w is None: return                z0, eff_val = calc_microstrip(w)                self.var_res_main.set(f"{z0:.2f} Ом")                best_w = w            else: # Ищем W                target_z = self._get(self.var_target_z0)                if target_z is None: return                low, high = 0.001, 100.0 * h                for _ in range(50):                    mid = (low + high) / 2                    z_curr, eff_curr = calc_microstrip(mid)                    if z_curr > target_z: low = mid                    else: high = mid                    best_w = mid                    eff_val = eff_curr                self.var_res_main.set(f"{best_w:.3f} мм")            self.var_res_eff.set(f"{eff_val:.2f}")            self.draw_profile(best_w, h, t)            if freq_ghz and freq_ghz > 0:                lambda_0 = 299.792 / freq_ghz                lambda_g = lambda_0 / math.sqrt(eff_val)                self.var_res_lambda.set(f"{lambda_g:.1f} мм")                                # Задержка (Propagation Delay) = sqrt(Eff) / c                # c = 300 mm/ns => Delay [ps/mm] = 1000 * sqrt(Eff) / 300                delay_ps_mm = (math.sqrt(eff_val) / 299.792) * 1000.0                self.var_res_delay.set(f"{delay_ps_mm:.2f} пс/мм")                                if abs(er - 1) > 1e-5:                     factor = (er / math.sqrt(eff_val)) * ((eff_val - 1) / (er - 1))                    loss_db_m = 27.3 * factor * (tand / (lambda_0 / 1000.0))                    self.var_res_loss.set(f"{loss_db_m:.2f} дБ/м")                else:                    self.var_res_loss.set("0.00 дБ/м")                                self.calc_phase_len()            else:                self.var_res_lambda.set("-")                self.var_res_loss.set("-")                self.var_res_delay.set("-")        except Exception as e:            print(f"Microstrip calc error: {e}")    def draw_profile(self, w, h, t):        # Метод теперь ВНУТРИ класса (правильный отступ)        if not self.canvas: return                c = self.canvas        c.delete("all")        W_canv = int(c['width']) if c['width'] != '0' else 400        H_canv = int(c['height']) if c['height'] != '0' else 220                cx = W_canv / 2        # Центрирование по вертикали        base_y = (H_canv // 2) + 50                # ВИЗУАЛЬНЫЙ МАСШТАБ        vis_h = 70        vis_t = 12                # Ограничиваем пропорции        ratio = w / h        vis_ratio = max(0.2, min(ratio, 5.0))        vis_w = vis_h * vis_ratio                # 1. GND        c.create_rectangle(20, base_y, W_canv-20, base_y+10, fill="#A9A9A9", outline="gray")        c.create_text(cx, base_y+20, text="GND (Земля)", fill="gray", font=("Segoe UI", 8))                # 2. Dielectric        c.create_rectangle(cx - 150, base_y - vis_h, cx + 150, base_y, fill="#F5F5DC", outline="gray")        c.create_text(cx - 130, base_y - vis_h/2, text=f"εr={self.var_er.get()}", fill="#888", font=("Segoe UI", 9))                # 3. Trace        tx1 = cx - vis_w/2        tx2 = cx + vis_w/2        ty2 = base_y - vis_h        ty1 = ty2 - vis_t        c.create_rectangle(tx1, ty1, tx2, ty2, fill="#B87333", outline="#8B4513")                # --- РАЗМЕРЫ ---        line_cfg = {"fill": "black", "width": 1}        arr_cfg = {"arrow": "both", "fill": "black", "width": 1}        txt_font = ("Segoe UI", 9, "bold")                # W (Сверху)        dim_y = ty1 - 25        c.create_line(tx1, ty1, tx1, dim_y, fill="#ccc", dash=(2,2))        c.create_line(tx2, ty1, tx2, dim_y, fill="#ccc", dash=(2,2))        c.create_line(tx1, dim_y + 5, tx2, dim_y + 5, **arr_cfg)        c.create_text(cx, dim_y - 10, text=f"W = {w:.3f} мм", font=txt_font)                # H (Справа)        dim_x = cx + 150 + 20        c.create_line(dim_x, base_y, dim_x, base_y - vis_h, **arr_cfg)        c.create_text(dim_x + 5, base_y - vis_h/2, text=f"H = {h} мм", anchor="w", font=txt_font)                # T (Выноска)        c.create_line(tx2, ty1 + vis_t/2, tx2 + 30, ty1 - 15, fill="black")        c.create_text(tx2 + 35, ty1 - 20, text=f"T = {t} мм", anchor="w", font=("Segoe UI", 8))