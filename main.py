# -*- coding: utf-8 -*-import tkinter as tkimport tkinter.ttk as ttkfrom ttkbootstrap import Stylefrom core.utils import tb# Импорт ваших модулейfrom modules.pfd_module import PowerFluxDensityModulefrom modules.s1p_module import S1PVSWRModule# from modules.converter_module import ConverterModule # Если естьclass EngineerToolboxApp:    def __init__(self, root):        self.root = root        self.root.title("Engineer Toolbox v2.0 Modular")        self.root.geometry("1200x800")                # Словарь для хранения загруженных модулей {class: instance}        # Это и есть "память" — мы не удаляем модули, а храним их здесь        self.modules = {}         self.current_module = None        self._build_layout()    def _build_layout(self):        # Основной контейнер        self.main_container = tb.Frame(self.root)        self.main_container.pack(fill="both", expand=True)        # --- БОКОВОЕ МЕНЮ (Слева) ---        sidebar = tb.Frame(self.main_container, width=250, bootstyle="light")        sidebar.pack(side="left", fill="y")                # Заголовок меню        tb.Label(sidebar, text="Инструменты", font=("Segoe UI", 12, "bold"), bootstyle="inverse-light")\            .pack(fill="x", ipady=10, padx=0)        # Список модулей (Название кнопки, Класс модуля)        menu_items = [            ("Плотность потока (ППМ)", PowerFluxDensityModule),            ("Анализ согласования (S1P)", S1PVSWRModule),            # ("Конвертер единиц", ConverterModule),        ]        # Создаем кнопки меню        for name, module_cls in menu_items:            btn = tb.Button(                sidebar,                 text=name,                 command=lambda m=module_cls: self.show_module(m),                bootstyle="secondary-outline" # Стиль кнопок            )            btn.pack(fill="x", padx=5, pady=2)        # --- ОБЛАСТЬ КОНТЕНТА (Справа) ---        self.content_area = tb.Frame(self.main_container)        self.content_area.pack(side="right", fill="both", expand=True, padx=10, pady=10)        # Сразу открываем первый модуль при запуске        if menu_items:            self.show_module(menu_items[0][1])    def show_module(self, module_cls):        """Логика переключения без потери данных"""                # 1. Если есть текущий модуль, просто скрываем его (pack_forget), но НЕ удаляем        if self.current_module:            self.current_module.frame.pack_forget()        # 2. Если модуль еще не создан — создаем и сохраняем в память        if module_cls not in self.modules:            # Создаем экземпляр            instance = module_cls(self)            # Строим интерфейс внутри content_area            instance.build_ui(self.content_area)            # Запоминаем            self.modules[module_cls] = instance                # 3. Достаем модуль из памяти и показываем        self.current_module = self.modules[module_cls]        self.current_module.frame.pack(fill="both", expand=True)        # 4. Если у модуля есть метод update_plot, вызываем его, чтобы освежить график (опционально)        if hasattr(self.current_module, "update_plot"):             # Небольшая задержка, чтобы UI успел отрисоваться            self.root.after(50, self.current_module.update_plot)    # Метод set_result оставлен пустым, так как мы убрали панель сообщений,    # но модули могут пытаться его вызвать. Чтобы не было ошибки:    def set_result(self, text, status_text="", color="primary"):        pass if __name__ == "__main__":    root = tk.Tk()    # Установка темы (cosmo, flatly, darker, superhero и т.д.)    style = Style(theme="flatly")     app = EngineerToolboxApp(root)    root.mainloop()